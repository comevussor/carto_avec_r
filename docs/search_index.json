[
["index.html", "Cartographie avec R Introduction", " Cartographie avec R Timothée Giraud &amp; Hugues Pécout 2019-01-09 Introduction Ce document se compose de trois parties permettant d’appréhender la création de cartes thématiques avec R. Les données spatiales Cartographie thématique Cartographie thématique avancée Voici une partie des packages dédiés à l’import, la manipulation, la transformation et l’affichage de données spatiales que nous utiliserons : sf, cartography, mapview, raster, SpatialPosition, spatstats. D’autres pourront être nécessaires ponctuellement. mapinsetr, osmdata, maptools, linemap, raster, rayshader, dplyr, photon, nominatim, banR, "],
["chapitre1.html", "Chapitre 1 Les données spatiales 1.1 Le package sf 1.2 Les systèmes de projections 1.3 Opérations de géotraitement 1.4 Géocodage d’adresses 1.5 Importer des données OSM", " Chapitre 1 Les données spatiales Il est possible d’importer, de manipuler, de traiter, d’afficher et d’exporter des données spatiales avec R. La grande majorité des opérations de géotraitement sont disponible dans R grace au package sf. Il devient alors possible d’utiliser R comme un SIG. 1.1 Le package sf Historique Historiquement trois packages permettent d’importer, de manipuler et de transformer les données spatiales : Le package rgdal qui est une interface entre R et les librairies GDAL (Geospatial Data Abstraction Library) et PROJ4 permet d’importer et d’exporter les données spatiales (les shapefiles par exemple) et aussi de gérer les projections cartographiques Le package sp fournit des classes et methodes pour les données spatiales dans R. C’est grace à ce package que l’on peut afficher des fond de cartes, inspecter une table attributaire etc. Le package rgeos donne accès à la librairie d’opérations spatiales GEOS (Geometry Engine - Open Source) et rend donc disponible les opérations SIG classiques : calcul de surface ou de périmètre, calcul de distances, aggrégations spatiales, zones tampons, intersections etc. La suite Le package sf ((Pebesma 2018a), (Pebesma 2018b)) a été publié fin 2016 par Edzer Pebesma (auteur de sp). Son objectif est de combiner dans les fonctionnalités de sp, rgeos et rgdal dans un package unique plus ergonomique. Ce package propose des objets plus simples (suivant le standard simple feature) dont la manipulation est plus aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe et les opérateurs du tidyverse. Aujourd’hui, les principaux développements dans l’écosystème spatial de R se détachent progressivement des 3 anciens (sp, rgdal, rgeos) pour se reposer sur sf. 1.1.1 Format des objets spatiaux sf Les objets sf sont des data.frame dont l’une des colonne contient des géométrie. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry). Ce format très pratique dans la mesure ou les données et les géométries sont intrinsequement liées dans un même objet. 1.1.2 Construction d’un objet sf 1.1.2.1 Couche de points library(sf) pt1_sfg &lt;- st_point(c(1,2)) pt2_sfg &lt;- st_point(c(3,4)) pt3_sfg &lt;- st_point(c(2,1)) (pt_sfc &lt;- st_sfc(pt1_sfg,pt2_sfg,pt3_sfg, crs = (4326))) Geometry set for 3 features geometry type: POINT dimension: XY bbox: xmin: 1 ymin: 1 xmax: 3 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs pt_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (pt_sf &lt;- st_sf(pt_df,geometry = pt_sfc)) Simple feature collection with 3 features and 4 fields geometry type: POINT dimension: XY bbox: xmin: 1 ymin: 1 xmax: 3 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs id cat var1 var2 geometry 1 1 A 10 2.3 POINT (1 2) 2 2 B 20 1.9 POINT (3 4) 3 3 A 30 4.0 POINT (2 1) plot(pt_sf) 1.1.2.2 Couche de polygones p1 &lt;- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)) p2 &lt;- rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0)) p3 &lt;- rbind(c(3,3), c(4,2), c(4,3), c(3,3)) pol1_sfg &lt;-st_polygon(list(p1)) pol2_sfg &lt;-st_polygon(list(p2)) pol3_sfg &lt;-st_polygon(list(p3)) (pol_sfc &lt;- st_sfc(pol1_sfg, pol2_sfg, pol3_sfg, crs = 4326)) Geometry set for 3 features geometry type: POLYGON dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs pol_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (pol_sf &lt;- st_sf(pol_df,geometry = pol_sfc)) Simple feature collection with 3 features and 4 fields geometry type: POLYGON dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs id cat var1 var2 geometry 1 1 A 10 2.3 POLYGON ((0 0, 1 0, 3 2, 2 ... 2 2 B 20 1.9 POLYGON ((3 0, 4 0, 4 1, 3 ... 3 3 A 30 4.0 POLYGON ((3 3, 4 2, 4 3, 3 3)) plot(pol_sf) 1.1.2.3 Couche de linestring p1 &lt;- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4)) p2 &lt;- rbind(c(3,0), c(4,0), c(4,1), c(3,1)) p3 &lt;- rbind(c(3,3), c(4,2), c(4,3)) ls1_sfg &lt;-st_linestring(p1) ls2_sfg &lt;-st_linestring(p2) ls3_sfg &lt;-st_linestring(p3) (ls_sfc &lt;- st_sfc(ls1_sfg, ls2_sfg, ls3_sfg, crs = 4326)) Geometry set for 3 features geometry type: LINESTRING dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs ls_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (ls_sf &lt;- st_sf(ls_df,geometry = ls_sfc)) Simple feature collection with 3 features and 4 fields geometry type: LINESTRING dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs id cat var1 var2 geometry 1 1 A 10 2.3 LINESTRING (0 0, 1 0, 3 2, ... 2 2 B 20 1.9 LINESTRING (3 0, 4 0, 4 1, ... 3 3 A 30 4.0 LINESTRING (3 3, 4 2, 4 3) plot(ls_sf) 1.1.3 Import / Export library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet=TRUE) st_write(obj = mtq, dsn = &quot;data/mtq.gpkg&quot;, layer = &quot;mtq&quot;, delete_layer = TRUE) Deleting layer `mtq&#39; using driver `GPKG&#39; Updating layer `mtq&#39; to data source `data/mtq.gpkg&#39; using driver `GPKG&#39; features: 34 fields: 23 geometry type: Polygon st_write(obj = mtq, &quot;data/mtq.shp&quot;, delete_layer = TRUE) Deleting layer `mtq&#39; using driver `ESRI Shapefile&#39; Writing layer `mtq&#39; to data source `data/mtq.shp&#39; using driver `ESRI Shapefile&#39; features: 34 fields: 23 geometry type: Polygon 1.1.4 Affichage de données Aperçu des variables head(mtq) Simple feature collection with 6 features and 23 fields geometry type: POLYGON dimension: XY bbox: xmin: 695444.4 ymin: 1598817 xmax: 717731.2 ymax: 1645182 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs INSEE_COM STATUT LIBGEO P13_POP C13_POP C13_CS1 C13_CS2 1 97201 Commune simple L&#39;Ajoupa-Bouillon 1830 1481.801 9.780866 48.90433 2 97202 Commune simple Les Anses-d&#39;Arlet 3929 3190.115 97.433459 170.50855 3 97203 Commune simple Basse-Pointe 3565 2983.215 39.510829 98.77707 C13_CS3 C13_CS4 C13_CS5 C13_CS6 C13_CS7 C13_CS8 P08_POP C08_POP C08_CS1 1 9.780866 102.6991 273.8642 288.5355 430.3581 317.8781 1691 1346.519 31.40569 2 109.612642 239.5239 560.2424 385.6741 746.5743 880.5453 3826 3067.742 49.00453 3 43.461911 181.7498 568.9559 565.0048 940.5055 545.2494 3804 3054.108 44.51803 C08_CS2 C08_CS3 C08_CS4 C08_CS5 C08_CS6 C08_CS7 C08_CS8 1 43.18282 11.77713 145.2513 223.7655 251.2455 380.7940 259.0969 2 143.95079 65.33937 216.3534 600.3054 459.4174 558.8020 974.5694 3 106.84327 27.70011 186.0292 448.1481 620.2845 881.5853 738.9993 geometry 1 POLYGON ((699261.2 1637681,... 2 POLYGON ((709840 1599026, 7... 3 POLYGON ((706092.8 1642964,... [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 3 rows ] plot(mtq) Affichage de la géométrie plot(st_geometry(mtq)) 1.1.5 Joindre des données On peut joindre d’autres données à un objet sf en utilisant la fonction merge(). mtq2016 &lt;- read.csv(file = &quot;data/mtq2016.csv&quot;) head(mtq2016) ID NOM Population.totale 1 97201 L&#39; Ajoupa-Bouillon 1964 2 97202 Les Anses-d&#39;Arlet 3686 3 97203 Basse-Pointe 3238 4 97234 Bellefontaine 1760 5 97204 Le Carbet 3655 6 97205 Case-Pilote 4522 mtq &lt;- merge(x = mtq, y = mtq2016, by.x = &quot;INSEE_COM&quot;, by.y = &quot;ID&quot;) head(mtq) Simple feature collection with 6 features and 25 fields geometry type: POLYGON dimension: XY bbox: xmin: 695444.4 ymin: 1598817 xmax: 717731.2 ymax: 1645182 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs INSEE_COM STATUT LIBGEO P13_POP C13_POP C13_CS1 C13_CS2 1 97201 Commune simple L&#39;Ajoupa-Bouillon 1830 1481.801 9.780866 48.90433 2 97202 Commune simple Les Anses-d&#39;Arlet 3929 3190.115 97.433459 170.50855 3 97203 Commune simple Basse-Pointe 3565 2983.215 39.510829 98.77707 C13_CS3 C13_CS4 C13_CS5 C13_CS6 C13_CS7 C13_CS8 P08_POP C08_POP C08_CS1 1 9.780866 102.6991 273.8642 288.5355 430.3581 317.8781 1691 1346.519 31.40569 2 109.612642 239.5239 560.2424 385.6741 746.5743 880.5453 3826 3067.742 49.00453 3 43.461911 181.7498 568.9559 565.0048 940.5055 545.2494 3804 3054.108 44.51803 C08_CS2 C08_CS3 C08_CS4 C08_CS5 C08_CS6 C08_CS7 C08_CS8 NOM 1 43.18282 11.77713 145.2513 223.7655 251.2455 380.7940 259.0969 L&#39; Ajoupa-Bouillon 2 143.95079 65.33937 216.3534 600.3054 459.4174 558.8020 974.5694 Les Anses-d&#39;Arlet 3 106.84327 27.70011 186.0292 448.1481 620.2845 881.5853 738.9993 Basse-Pointe Population.totale geometry 1 1964 POLYGON ((699261.2 1637681,... 2 3686 POLYGON ((709840 1599026, 7... 3 3238 POLYGON ((706092.8 1642964,... [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 3 rows ] 1.2 Les systèmes de projections 1.2.1 Consulter la projection d’un objet st_crs(mtq) Coordinate Reference System: EPSG: 32620 proj4string: &quot;+proj=utm +zone=20 +datum=WGS84 +units=m +no_defs&quot; 1.2.2 Modifier la projection d’un objet mtq_reproj &lt;- st_transform(mtq, 2154) plot(st_geometry(mtq)) title(&quot;WGS 84 / UTM zone 20N&quot;) plot(st_geometry(mtq_reproj)) title(&quot;RGF93 / Lambert-93&quot;) 1.3 Opérations de géotraitement 1.3.1 Selection par attributs Les objets sf sont des data.frame, on peut donc selectionner leur lignes et leur colonnes de la même manière que les data.frame. # selection de ligne mtq[1:2, ] Simple feature collection with 2 features and 23 fields geometry type: POLYGON dimension: XY bbox: xmin: 697601.7 ymin: 1598817 xmax: 710461.9 ymax: 1640521 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs INSEE_COM STATUT LIBGEO P13_POP C13_POP C13_CS1 C13_CS2 1 97201 Commune simple L&#39;Ajoupa-Bouillon 1830 1481.801 9.780866 48.90433 2 97202 Commune simple Les Anses-d&#39;Arlet 3929 3190.115 97.433459 170.50855 C13_CS3 C13_CS4 C13_CS5 C13_CS6 C13_CS7 C13_CS8 P08_POP C08_POP C08_CS1 1 9.780866 102.6991 273.8642 288.5355 430.3581 317.8781 1691 1346.519 31.40569 2 109.612642 239.5239 560.2424 385.6741 746.5743 880.5453 3826 3067.742 49.00453 C08_CS2 C08_CS3 C08_CS4 C08_CS5 C08_CS6 C08_CS7 C08_CS8 1 43.18282 11.77713 145.2513 223.7655 251.2455 380.794 259.0969 2 143.95079 65.33937 216.3534 600.3054 459.4174 558.802 974.5694 geometry 1 POLYGON ((699261.2 1637681,... 2 POLYGON ((709840 1599026, 7... mtq[mtq$LIBGEO==&quot;Fort-de-France&quot;, ] Simple feature collection with 1 feature and 23 fields geometry type: POLYGON dimension: XY bbox: xmin: 704448.6 ymin: 1614283 xmax: 711650.9 ymax: 1626937 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs INSEE_COM STATUT LIBGEO P13_POP C13_POP C13_CS1 C13_CS2 9 97209 Préfecture de région Fort-de-France 84174 68712.33 86.57284 2720.489 C13_CS3 C13_CS4 C13_CS5 C13_CS6 C13_CS7 C13_CS8 P08_POP C08_POP C08_CS1 9 4000.387 8407.424 13799.23 7309.136 16184.26 16204.84 89000 71566.82 119.0608 C08_CS2 C08_CS3 C08_CS4 C08_CS5 C08_CS6 C08_CS7 C08_CS8 9 2480.105 3976.898 8630.605 15437.6 7964.513 15996.58 16961.46 geometry 9 POLYGON ((711183.1 1619627,... # selection de colonnes mtq[mtq$LIBGEO==&quot;Fort-de-France&quot;, 1:4] Simple feature collection with 1 feature and 4 fields geometry type: POLYGON dimension: XY bbox: xmin: 704448.6 ymin: 1614283 xmax: 711650.9 ymax: 1626937 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs INSEE_COM STATUT LIBGEO P13_POP geometry 9 97209 Préfecture de région Fort-de-France 84174 POLYGON ((711183.1 1619627,... 1.3.2 Selection spatiale Selection des communes interectants Fort-de-France fdf &lt;- mtq[mtq$LIBGEO == &quot;Fort-de-France&quot;, ] mtq$fdf &lt;- st_intersects(x = mtq, y = fdf, sparse = FALSE) plot(st_geometry(mtq)) plot(st_geometry(mtq[mtq$fdf,]), col = &quot;grey&quot;, add = TRUE) 1.3.3 Extraire des centroides mtq_c &lt;- st_centroid(mtq) plot(st_geometry(mtq)) plot(st_geometry(mtq_c), add=TRUE, cex=1.2, col=&quot;red&quot;, pch=20) 1.3.4 Créer une matrice de distances mat &lt;- st_distance(x=mtq_c,y=mtq_c) mat[1:5,1:5] Units: [m] [,1] [,2] [,3] [,4] [,5] [1,] 0.000 35297.56 3091.501 12131.617 17136.310 [2,] 35297.557 0.00 38332.602 25518.913 18605.249 [3,] 3091.501 38332.60 0.000 15094.702 20226.198 [4,] 12131.617 25518.91 15094.702 0.000 7177.011 [5,] 17136.310 18605.25 20226.198 7177.011 0.000 1.3.5 Agréger des polygones mtq_u &lt;- st_union(mtq) plot(st_geometry(mtq), col=&quot;lightblue&quot;) plot(st_geometry(mtq_u), add=T, lwd=2, border = &quot;red&quot;) 1.3.6 Agréger des polygones en fonction d’une variable library(dplyr) mtq_u2 &lt;- mtq %&gt;% group_by(STATUT) %&gt;% summarize(P13_POP=sum(P13_POP)) plot(mtq_u2[&quot;STATUT&quot;], key.pos = NULL) 1.3.7 Construire une zone tampon mtq_b &lt;- st_buffer(x = mtq_u, dist = 2000) plot(st_geometry(mtq), col=&quot;lightblue&quot;) plot(st_geometry(mtq_u), add=T, lwd=2) plot(st_geometry(mtq_b), add=T, lwd=2, border = &quot;red&quot;) 1.3.8 Réaliser une intersection m &lt;- rbind(c(700015,1624212), c(700015,1641586), c(719127,1641586), c(719127,1624212), c(700015,1624212)) p &lt;- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq)) plot(st_geometry(mtq)) plot(p, border=&quot;red&quot;, lwd=2, add=T) mtq_z &lt;- st_intersection(x = mtq, y = p) plot(st_geometry(mtq)) plot(st_geometry(mtq_z), col=&quot;red&quot;, border=&quot;green&quot;, add=T) plot(st_geometry(mtq_z)) 1.3.9 Compter des points dans un polygone pts &lt;- st_sample(x = mtq, size = 50) plot(st_geometry(mtq)) plot(pts, pch = 20, col = &quot;red&quot;, add=TRUE, cex = 1) inter &lt;- st_intersects(mtq, pts) mtq$nbpts &lt;- sapply(X = inter, FUN = length) plot(st_geometry(mtq)) plot(st_geometry(mtq[mtq$nbpts&gt;2,]), col = &quot;grey&quot;, add=TRUE) plot(pts, pch = 20, col = &quot;red&quot;, add=TRUE, cex = 1) 1.3.10 Construire des polygones de Voronoi google: “st_voronoi R sf” (https://github.com/r-spatial/sf/issues/474 &amp; https://stackoverflow.com/questions/45719790/create-voronoi-polygon-with-simple-feature-in-r) mtq_v &lt;- st_voronoi(x = st_union(mtq_c)) mtq_v &lt;- st_intersection(st_cast(mtq_v), st_union(mtq)) mtq_v &lt;- st_join(x = st_sf(mtq_v), y = mtq_c, join=st_intersects) mtq_v &lt;- st_cast(mtq_v, &quot;MULTIPOLYGON&quot;) plot(st_geometry(mtq_v), col=&#39;lightblue&#39;) 1.4 Géocodage d’adresses Plusieurs packages permettent de géocoder des adresses. photon # remotes::install_github(repo = &#39;rCarto/photon&#39;) library(photon) address &lt;- c(&quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;, &quot;8 place Paul Ricoeur, 75013 Paris&quot;) place &lt;- photon::geocode(address, limit = 1, key = &quot;place&quot;, lang = &quot;fr&quot;) place saveRDS(object = place, file = &quot;data/place1.rds&quot;) location osm_id osm_type name housenumber 1 19 rue Michel Bakounine, 29600 Morlaix, France 3241060871 N &lt;NA&gt; 19 2 8 place Paul Ricoeur, 75013 Paris 2608793979 N &lt;NA&gt; 8 street postcode city state country osm_key osm_value lon 1 Rue Michel Bakounine 29600 Morlaix Bretagne France place house -3.816435 2 Place Paul Ricoeur 75013 Paris Île-de-France France place house 2.382483 lat msg 1 48.59041 &lt;NA&gt; 2 48.82670 &lt;NA&gt; nominatim # remotes::install_github(&quot;hrbrmstr/nominatim&quot;) library(nominatim) address &lt;- c(URLencode(&quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;), URLencode(&quot;8 place Paul Ricoeur, 75013 Paris&quot;)) place &lt;- osm_geocode(address, country_codes = &quot;FR&quot;, key = &quot;UneClefMapQuestValide&quot;) place place_id 1 44644129 2 27209988 licence 1 Data © OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright 2 Data © OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright osm_type osm_id lat lon 1 node 3241060871 48.59041 -3.816435 2 node 2608793979 48.82670 2.382483 display_name 1 19, Rue Michel Bakounine, Ploujean, Kerozar, Morlaix, Finistère, Brittany, Metropolitan France, 29600, France 2 8, Place Paul Ricoeur, Gare, 13th Arrondissement, Paris, Ile-de-France, Metropolitan France, 75013, France class type importance bbox_left bbox_top bbox_right bbox_bottom 1 place house 0.741 48.59036 48.59046 -3.816485 -3.816384 2 place house 0.631 48.82665 48.82675 2.382433 2.382533 banR (pour des adresses en France) library(banR) address &lt;- c(&quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;, &quot;8 place Paul Ricoeur, 75013 Paris&quot;) place &lt;- geocode_tbl(tbl = data.frame(address), adresse = &quot;address&quot;) place # A tibble: 2 x 14 address latitude longitude result_label result_score result_type result_id &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 19 rue… 48.6 -3.82 19 Rue Mich… 0.78 housenumber ADRNIVX_… 2 8 plac… 48.8 2.38 8 Place Pau… 0.93 housenumber ADRNIVX_… # ... with 7 more variables: result_housenumber &lt;int&gt;, result_name &lt;chr&gt;, # result_street &lt;chr&gt;, result_postcode &lt;int&gt;, result_city &lt;chr&gt;, result_context &lt;chr&gt;, # result_citycode &lt;chr&gt; 1.5 Importer des données OSM OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le Monde entier. Le package osmdata (Padgham et al. 2017) permet d’extraire des données depuis OSM. library(sf) library(osmdata) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # Définition d&#39;une bounding box q &lt;- opq(bbox=st_bbox(st_transform(mtq,4326))) # Extraction des resaturants res &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;restaurant&quot;) res.sf &lt;- osmdata_sf(res) res.sf.pts &lt;- res.sf$osm_points[!is.na(res.sf$osm_points$amenity),] res.sf.pol &lt;- res.sf$osm_polygons st_geometry(res.sf.pol) &lt;- st_centroid(st_geometry(res.sf.pol)) # Extraction des fast food ff &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;,value = &quot;fast_food&quot;) ff.sf &lt;- osmdata_sf(ff) ff.sf.pts &lt;- ff.sf$osm_points[!is.na(ff.sf$osm_points$amenity),] ff.sf.pol &lt;- ff.sf$osm_polygons st_geometry(ff.sf.pol) &lt;- st_centroid(st_geometry(ff.sf.pol)) # Extraction des cafés caf &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;cafe&quot; ) caf.sf &lt;- osmdata_sf(caf) caf.sf.pts &lt;- caf.sf$osm_points[!is.na(caf.sf$osm_points$amenity),] caf.sf.pol &lt;- caf.sf$osm_polygons st_geometry(caf.sf.pol) &lt;- st_centroid(st_geometry(caf.sf.pol)) # regroupement des 3 types d&#39;établissement resto &lt;- rbind( res.sf.pts[, c(&quot;osm_id&quot;, &quot;name&quot;)], res.sf.pol[, c(&quot;osm_id&quot;, &quot;name&quot;)], ff.sf.pts[, c(&quot;osm_id&quot;, &quot;name&quot;)], ff.sf.pol[, c(&quot;osm_id&quot;, &quot;name&quot;)], caf.sf.pts[, c(&quot;osm_id&quot;, &quot;name&quot;)], caf.sf.pol[, c(&quot;osm_id&quot;, &quot;name&quot;)] ) resto &lt;- st_transform(resto, st_crs(mtq)) # Affichage des restaurants plot(st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, bg = &quot;lightblue1&quot;) plot(st_geometry(resto), add=TRUE, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) title(&quot;Répartition des restaurants&quot;) mtext(text = &quot;INSEE, 2016 - OSM, 2018&quot;,side = 1, line = -1, cex = 0.8) References "],
["chapitre2.html", "Chapitre 2 Cartographie thématique 2.1 Le package cartography 2.2 Représentations usuelles 2.3 Combinaisons de représentations 2.4 Éléments d’habillage 2.5 Autres fonctionnalités utiles", " Chapitre 2 Cartographie thématique Nous ne détaillerons pas ici les règles de la cartographie thématique. Le lecteur pourra se référer à divers ouvrages de référence : Bertin (1967), Pumain and Béguin (2010), Lambert and Zanin (2016) 2.1 Le package cartography Le package cartography (Giraud and Lambert 2018a) permet de créer et intégrer des cartes thématiques dans sa chaîne de traitements en R. Il permet des représentations cartographiques tels que les cartes en symboles proportionnels, des cartes choroplèthes, des typologies, des cartes de flux ou des cartes de discontinuités. Il offre également des fonctions qui permettent d’améliorer la réalisation de la carte, comme des palettes de couleur, des éléments d’habillage (échelle, flèche du nord, titre, légende…), d’y rattacher des labels ou d’accéder à des APIs cartographiques. Pour utiliser ce package plusieurs sources peuvent être consultées : La documentation du package accessible sur internet ou directement dans R ?cartography, La vignette associée au package présente des exemples de scripts vignette(&quot;cartography&quot;), Le blog R Géomatique qui met à disposition ressources et exemples liés au package et plus généralement à l’écosystème spatiale de R, La cheat sheet de cartography, qui résume les principales fonctions du package de façon synthétique. Les fonctions de cartography dédiées à la représentation utilisent le suffixe Layer. En général l’argument x est utilisé par un objet et l’argument var sert à renseigner la variable à représenter. 2.2 Représentations usuelles 2.2.1 Carte de symboles proportionnels Les cartes de symboles proportionnels sont utilisées pour représenter les variables de stocks. La fonction propSymbolsLayer() propose cette représentation, plusieurs symboles sont disponibles : cercles, carrés et bars. library(cartography) library(sf) # Import des données mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # Communes plot( st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot; ) # Symboles proportionnels propSymbolsLayer( x = mtq, var = &quot;P13_POP&quot;, legend.title.txt = &quot;Population totale\\n(2013)&quot; ) # Titre title(main = &quot;Population en Martinique&quot;) 2.2.2 Carte choroplèthe Les cartes de choroplèthes sont utilisées pour représenter les variables de ratios. La fonction choroLayer() propose cette représentation. Les arguments nclass, method et breaks servent à paramétrer les discrétisations et la fonction getBreaks() permet de travailler sur les discrétisations en dehors de la fonction choroLayer(). De même, l’argument col est utilisé pour renseigner une palette de couleur mais plusieurs fonctions peuvent être utilisées pour paramétrer les palettes en dehors de la fonction. mtq$cagr &lt;- (((mtq$P13_POP / mtq$P08_POP)^(1/4)) - 1) * 100 choroLayer( x = mtq, var = &quot;cagr&quot;, breaks = c(-6.14,-2,-1,0,1,2), col = c(&quot;#135D89&quot;, &quot;#4D95BA&quot;, &quot;#96D1EA&quot;, &quot;#FCDACA&quot;, &quot;#EC4E49&quot;), legend.title.txt = &quot;Taux de croissance\\nannuel moyen\\n(2008-2013)&quot; ) title(main = &quot;Evolution de la population&quot;) 2.2.3 Carte de typologie Les cartes de typologies sont utilisées pour représenter les variables qualitatives. La fonction typoLayer() propose cette représentation. L’argument legend.values.order sert à ordonner les modalités dans la légende. typoLayer( x = mtq, var=&quot;STATUT&quot;, legend.values.order = c(&quot;Préfecture de région&quot;, &quot;Sous-préfecture&quot;, &quot;Commune simple&quot;), col = c(&quot;aquamarine4&quot;, &quot;yellow3&quot;,&quot;wheat&quot;), legend.pos = &quot;topright&quot;, legend.title.txt = &quot;Statut administratif&quot; ) title(&quot;Statut Administratif&quot;) 2.3 Combinaisons de représentations Plusieurs fonctions sont dédiées à la représentation combinées de 2 variables. 2.3.1 Carte de stocks et de ratios La fonction propSymbolsChoroLayer() représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur repose sur la discrétisation d’une seconde variable. La fonction utilise les arguments des fonctions propSymbolsLayer() et choroLayer(). plot( st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, bg = &quot;lightblue1&quot; ) propSymbolsChoroLayer( x = mtq, var= &quot;P13_POP&quot;, var2 = &quot;cagr&quot;, breaks = c(-6.14,-2,-1,0,1,2), col = c(&quot;#135D89&quot;, &quot;#4D95BA&quot;, &quot;#96D1EA&quot;, &quot;#FCDACA&quot;, &quot;#EC4E49&quot;), legend.var.pos = &quot;topright&quot;, legend.var.title.txt = &quot;Population totale\\n(2013)&quot;, legend.var2.pos = &quot;bottomleft&quot;, legend.var2.title.txt = &quot;Taux de croissance\\nannuel moyen\\n(2008-2013)&quot; ) title(&quot;Evolution de la population&quot;) 2.3.2 Carte de stocks et de qualitative La fonction propSymbolsTypoLayer() représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur représente les modalités d’une variable qualitative. La fonction utilise les arguments des fonctions propSymbolsLayer() et typoLayer(). plot( st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, bg = &quot;lightblue1&quot; ) propSymbolsTypoLayer( x = mtq, var = &quot;P13_POP&quot;, symbols = &quot;circle&quot;, var2 = &quot;STATUT&quot;, col = c(&quot;aquamarine4&quot;, &quot;yellow3&quot;,&quot;wheat&quot;), legend.var.pos = &quot;bottomleft&quot;, legend.var.title.txt = &quot;Population totale\\n(2013)&quot;, legend.var2.title.txt = &quot;Statut administratif&quot;, legend.var2.values.order = c(&quot;Préfecture de région&quot;, &quot;Sous-préfecture&quot;, &quot;Commune simple&quot;) ) title(&quot;Population en Martinique&quot;) 2.4 Éléments d’habillage Une carte thématique doit être “habillée”, certains éléments aditionnels doivent être présents : le titre, l’auteur, la source, l’échelle, l’orientation… 2.4.1 Habillage complet La fonction layoutLayer() permet d’afficher tous ces éléments. plot( st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot; ) layoutLayer( title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, north = TRUE ) Plusieurs arguments permettent de paramétrer plus finement les éléments d’habillage pour aboutir à des cartes plus personnalisées (tabtitle, col, coltitle, theme…). plot( st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot; ) layoutLayer( title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, north = TRUE, scale = 5, frame = FALSE, tabtitle = TRUE, theme = &quot;turquoise.pal&quot; ) 2.4.2 Flèche d’orientation La fonction north() permet de mieux choisir la position et l’aspect de la flêche d’orientation. plot( st_geometry(mtq), col = &quot;red&quot;, border = &quot;white&quot;, bg = &quot;grey80&quot; ) north(pos = &quot;topleft&quot;, col = &quot;red&quot;) layoutLayer( title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, frame = FALSE, col = &quot;grey20&quot;, coltitle = &quot;grey80&quot;, tabtitle = TRUE ) 2.4.3 Échelle La fonction barscale() permet de mieux choisir la position et l’aspect de l’échelle. plot( st_geometry(mtq), col = &quot;red&quot;, border = &quot;white&quot;, bg = &quot;grey80&quot; ) barscale( size = 5, lwd = 2, cex = 1.2, pos = c(713712.6,1594777) ) layoutLayer( title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, frame = FALSE, col = &quot;grey20&quot;, coltitle = &quot;grey80&quot;, tabtitle = TRUE, scale = NULL ) 2.4.4 Étiquettes La fonction labelLayer() est dédiée à l’afichage d’étiquettes. plot( st_geometry(mtq), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, bg = &quot;#A6CAE0&quot; ) labelLayer( x = mtq, txt = &quot;LIBGEO&quot;, col= &quot;black&quot;, cex = 0.7, font = 4, halo = TRUE, bg = &quot;white&quot;, r = 0.1, overlap = FALSE, show.lines = FALSE ) layoutLayer( title = &quot;Communes&quot;, tabtitle = TRUE, author = &quot;INSEE, 2016&quot;, sources =&quot;&quot;, north =TRUE, frame = FALSE, scale = 5 ) 2.5 Autres fonctionnalités utiles 2.5.1 Utiliser un fond de carte OSM La fonction getTiles() permet de télécharger des fonds de cartes OSM et la fonction tilesLayer() permet de les afficher. type &lt;- c( &quot;osm&quot;, &quot;hotstyle&quot;, &quot;hikebike&quot;, &quot;osmgrayscale&quot;, &quot;stamenbw&quot;, &quot;stamenwatercolor&quot;, &quot;cartodark&quot;, &quot;cartolight&quot;) par(mar = c(0,0,0,0), mfrow = c(3,3)) for (i in type){ tilesLayer(getTiles(x = mtq, type = i, crop=TRUE)) mtext(side = 3, line = -1.5, text = i, col=&quot;red&quot;) } 2.5.2 Mise en page 2.5.2.1 Ajuster les marges de la figures Pour modifier les marges d’une figure (carte ou autre) il faut utiliser la fonction par() et son argument mar. par(bg=&quot;grey80&quot;) plot(st_geometry(mtq), main=&quot;Marges par défaut&quot;) box() par(mar=c(0,0,1.2,0)) plot(st_geometry(mtq), main=&quot;Marges paramétrées&quot;) box() La fonction dev.off() efface tous les graphiques en mémoire et permet de réinitialiser les marges avec leurs valeurs par défaut. 2.5.2.2 Afficher plusieurs cartes sur la même figure par(mfrow=c(1,2)) 2.5.2.3 Obtenir un ratio de figure adapté getFigDim() 2.5.3 Créer un effet crayonné library(sf) mtq_pencil &lt;- getPencilLayer(x = mtq) typoLayer( x = mtq_pencil, var=&quot;STATUT&quot;, col = c(&quot;aquamarine4&quot;, &quot;yellow3&quot;,&quot;wheat&quot;), legend.values.order = c(&quot;Préfecture de région&quot;, &quot;Sous-préfecture&quot;, &quot;Commune simple&quot;), legend.pos = &quot;topright&quot;, legend.title.txt = &quot;Status&quot; ) plot(st_geometry(mtq), add = TRUE, ldy=2) layoutLayer(title = &quot;Statut Administratif&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) 2.5.4 Ajouter un ombrage à une couche plot(st_geometry(mtq) + c(500, -500), col = &quot;grey50&quot;, border = NA, bg = &quot;lightblue1&quot;) plot(st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, add=TRUE) layoutLayer(title = &quot;Communes&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, north=TRUE, frame=FALSE, scale = 5) 2.5.5 Palettes de couleurs La fonction display.carto.all() permet d’afficher toutes palettes de couleurs disponibles dans cartography. display.carto.all(20) La fonction display.carto.pal() permet de détailler une palette de couleurs. display.carto.pal(&quot;orange.pal&quot;) La fonction carto.pal() permet de construire une palette de couleur. Il est possible de créer des palettes associant 2 couleurs. mypal &lt;- carto.pal(pal1 = &quot;wine.pal&quot;, n1 = 5, pal2 = &quot;green.pal&quot;, n2 = 4) image(1:9, 1, as.matrix(1:9), col=mypal, xlab = &quot;&quot;, ylab = &quot;&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;,bty = &quot;n&quot;) 2.5.6 Discrétisations La fonction getBreaks() met à disposition les méthodes de discrétisations de variables classique : quantiles, moyenn/écart-type, amplitudes égales, moyennes emboitées, Fisher-Jenks, géométrique … var &lt;- mtq$cagr moy &lt;- mean(var) med &lt;- median(var) std &lt;- sd(var) # Quantile intervals breaks &lt;- getBreaks(v = var, nclass = 6, method = &quot;quantile&quot;) hist(var, probability = TRUE, breaks = breaks, main=&quot;quantiles&quot;, col = carto.pal(pal1 = &quot;wine.pal&quot;,3, &quot;green.pal&quot;, 3)) rug(var) abline(v = med, col = &quot;blue&quot;, lwd = 3) # Mean and standard deviation (msd) breaks &lt;- getBreaks(v = var, method = &quot;msd&quot;, k = 1, middle = TRUE) hist(var, probability = TRUE, breaks = breaks, main=&quot;moyenne / écart-type&quot;, col = carto.pal(pal1 = &quot;wine.pal&quot;,3 , &quot;green.pal&quot;, 2, middle = TRUE)) rug(var) abline(v = moy, col = &quot;red&quot;, lwd = 3) abline(v = moy + 0.5 * std, col = &quot;blue&quot;, lwd = 3) abline(v = moy - 0.5 * std, col = &quot;blue&quot;, lwd = 3) 2.5.7 Création de cartons Le package mapinsetr(Giraud and Lambert 2018b) est dédié à la crétion de cartons cartographiques. Il n’est pas sur le CRAN pour l’instant, mais on peut l’installer via le package remotes. remotes::install_github(&quot;riatelab/mapinsetr&quot;) mapinsetr permet de découper, redimensionner et déplacer une zone d’un fond de carte. library(mapinsetr) library(cartography) library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) resto &lt;- st_read(&quot;data/resto.gpkg&quot;, quiet = TRUE) # Création d&#39;un masque box_FDF &lt;- create_mask(bb = c(706880, 1615030, 708650, 1616870), prj = st_crs(mtq)) # Découpage, déplacement et redimentionnement des couches sous le masque zbox_FDF &lt;- move_and_resize( x = box_FDF, mask = box_FDF, xy = c(689000, 1603000), k = 7 ) zmtq_FDF &lt;- move_and_resize( x = mtq, mask = box_FDF, xy = c(689000, 1603000), k = 7 ) zresto_FDF &lt;- move_and_resize( x = resto, mask = box_FDF, xy = c(689000, 1603000), k = 7 ) # Affichage de la carte et des couhes crées plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) plot(st_geometry(resto), add=T, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) plot(st_geometry(box_FDF), border = &quot;red&quot;, add = T, lwd = 2) plot(st_geometry(zmtq_FDF), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, add=TRUE) plot(st_geometry(zresto_FDF), add=TRUE, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) plot(st_geometry(zbox_FDF), border = &quot;red&quot;, add = T, lwd = 2) layoutLayer(title = &quot;Carte initiale + couches créées&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, north=TRUE, frame=FALSE, scale = 5) # Création de couches unqiues comprenant le zoom resto &lt;- inset_rbinder(l = list(resto, zresto_FDF)) mtq &lt;- inset_rbinder(l = list(mtq, zmtq_FDF)) box &lt;- inset_rbinder(l = list(box_FDF, zbox_FDF)) plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) plot(st_geometry(resto), add=T, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) plot(st_geometry(box), border = &quot;red&quot;, add = T, lwd = 2) layoutLayer(title = &quot;Carte finale avec carton&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, north=TRUE, frame=FALSE, scale = 5) References "],
["chapitre3.html", "Chapitre 3 Cartographie thématique avancée 3.1 Cartographie interactive 3.2 Les cartogrammes 3.3 Les grilles régulières 3.4 Les cartes de discontinuités 3.5 Le lissage spatial 3.6 3D", " Chapitre 3 Cartographie thématique avancée 3.1 Cartographie interactive Le package mapview (Appelhans et al. 2018) utilise le package leaflet (Cheng, Karambelkar, and Xie 2018) basé sur la librairie javascript Leaflet (Agafonkin 2015) pour créer des cartes interactives. La création de carte est assez aisée, la documentation est un peu dense. library(sf) library(mapview) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet=TRUE) resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;, quiet = TRUE) mapview( resto, map.types = &quot;OpenStreetMap&quot;, col.regions = &quot;#940000&quot;, label = resto$name,alpha.regions=90,color = &quot;white&quot;, legend = TRUE, layer.name = &quot;Restaurants&quot;, homebutton = FALSE, lwd = 0.5, popup = NA ) + mapview( mtq, col.regions = &quot;lightblue&quot;, color = &quot;white&quot;, legend = TRUE, label = mtq$LIBGEO, alpha.regions= 0.5, map.types = &quot;OpenStreetMap&quot;, lwd = 0.5, layer.name = &quot;Communes&quot;, homebutton = FALSE, popup = popupTable(mtq, zcol = 1:4, row.numbers = FALSE, feature.id = FALSE) ) 3.2 Les cartogrammes L’anamorphose classique est une représentation des États (ou de mailles quelconques) par des rectangles ou des polygones quelconques en fonction d’une quantité qui leur est rattaché. (…) On s’efforce de garder l’arrangement général des mailles ou la silhouette du continent.&quot; Brunet, Ferras, and Théry (1993) Nous aborderons ici 3 types d’anamorphoses ou cartogrammes : Les cartogrammes de Dorling (Dorling 1996) Les cartogrammes non contigus (Olson 1976) Les cartogrammes contigus (Dougenik, Chrisman, and Niemeyer 1985) Vous trouverez un cours complet sur les anamorphoses ici : Les anamorphoses cartographiques (Lambert 2015). Pour réaliser les cartogrammes nous utilisons le package cartogram (Jeworutzki 2018). 3.2.1 Les cartogrammes de Dorling Les territoires sont représentés par des figurés (cercles, des carrés ou des rectangles) ne se recouvrant pas dont les surfaces sont proportionnelle à une variable. Les positions des figurés sont définie selon les positions de départ. (McCormick 2017) On identifie assez mal l’espace. On peut nommer les cercles pour se repérer et/ou s’aider de la couleur pour faire apparaitre des clusters et mieux identifier les blocks géographiques. La perception des quantités est très bonne. Les tailles de cercles sont vraiment comparables. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) mtq_dorling &lt;- cartogram_dorling(x = mtq, weight = &quot;P13_POP&quot;, k = 12) plot(st_geometry(mtq_dorling), col = &quot;#940000&quot;, border= &quot;white&quot;, bg = &quot;lightblue&quot;) labelLayer(x = mtq_dorling, txt = &quot;LIBGEO&quot;, overlap = FALSE, show.lines = FALSE, halo = TRUE, r = .15) layoutLayer(&quot;Population en Martinique - Cartogramme de Dorling&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) 3.2.2 Les cartogrammes non continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. La forme des polygones est ressemblante. (Cauvin, Escobar, and Serradj 2013) La topologie des régions est perdue. La conservation de la forme des polygones est optimale. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) mtq_ncont &lt;- cartogram_ncont(x = mtq, weight = &quot;P13_POP&quot;, k = 1.5) plot(st_geometry(mtq), col = NA, border = &quot;white&quot;, lwd = 0.5, bg = &quot;lightblue&quot;) plot(st_geometry(mtq_ncont), col = &quot;#940000&quot;, border= &quot;white&quot;, add=TRUE) layoutLayer(&quot;Population en Martinique - Cartogramme de Olson&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) 3.2.3 Les cartogrammes continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. Pour conserver la contiguité, la forme des polygones est fortement transformée. (Paull and Hennig 2016) La forme des polygones est fortement distordue. C’est une “vraie carte de géographie” : la topologie et la contiguité sont conservées. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # transformation POLYGON =&gt; MULTIPOLYGON mtq &lt;- st_cast(mtq, &quot;MULTIPOLYGON&quot;) mtq_cont &lt;- cartogram_cont(x = mtq, weight = &quot;P13_POP&quot;, prepare = &quot;none&quot;) plot(st_geometry(mtq_cont), col = &quot;#940000&quot;, border= &quot;white&quot;, bg = &quot;lightblue&quot;) layoutLayer(&quot;Population en Martinique - Cartogramme de Dougenik&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) 3.2.4 Forces et faiblesses des cartogrammes Les cartogrammes sont des représentations cartographiques perçues comme innovante (bien que la methode date de 40 ans). Ces images très généralisées rendent bien compte des quantités et des gradiants. Ce sont de vraies images de communication qui provoquent, suscitent l’intérêt, véhiculent un message fort, interpellent. Mais les cartogrammes induisent une perte des repères visuels (difficile de retrouver son pays, ou sa région sur la carte), demandent un effort de lecture qui peut être important et ne permettent pas de gérer des données manquantes. 3.3 Les grilles régulières La méthode du carroyage consiste à découper l’espace géographique en un maillage formé de carrés réguliers dans une projection donnée. La donnée est répartie sur ce quadrillage régulier au prorata de la surface représentée. Le quadrillage permet ainsi de s’affranchir des mailles administratives. Ces représentation induisent une perte de précision. Les maillages produit n’ont pas de signification. La version simple (les valeurs sont redistribuées au prorata de la surface), implique une equirépartition du phénomène dans chaque unités. La comparaison de maillages différents, à plusieurs dates ou de différentes sources est rendue possible. La fonction getGridLayer() du package cartography permet de construire ces grilles régulières. library(sf) library(cartography) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # Plot dentsity of population mtq$dens &lt;- mtq$P13_POP / (st_area(mtq) / (1000 * 1000)) bks &lt;- getBreaks(v = mtq$dens, method = &quot;q6&quot;) cols &lt;- carto.pal(pal1 = &quot;taupe.pal&quot;, n1 = 6) choroLayer( x = mtq, var = &quot;dens&quot;, breaks = bks, border = &quot;burlywood3&quot;, col = cols, legend.pos = &quot;topright&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Densité de population\\n(hab/km2)&quot; ) layoutLayer(&quot;Population en Martinique&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) mygrid &lt;- getGridLayer(x = mtq, cellsize = 3000 * 3000, type = &quot;hexagonal&quot;, var = &quot;P13_POP&quot;) ## conversion from square meter to square kilometers mygrid$densitykm &lt;- mygrid$P13_POP / (mygrid$gridarea / (1000 * 1000)) choroLayer( x = mygrid, var = &quot;densitykm&quot;, breaks = bks, border = &quot;burlywood3&quot;, col = cols, legend.pos = &quot;topright&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Densité de population\\n(hab/km2)&quot; ) plot(st_geometry(mtq), lwd = 0.2, add=TRUE, border = &quot;#ffffff75&quot;) layoutLayer(&quot;Population en Martinique&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) 3.4 Les cartes de discontinuités Ce type de représentation permet de souligner cartographiquement les discontinuités territoriales d’un phénomène. L’accent est porter sur ce qui distingue des territoires. Pour chaque frontière nous calculons le rapports ou la différence des valeurs des polygones de part et d’autre. Puis nous représentons la frontière par un figuré d’autant plus épais que la différence est forte. Il est souvent bénéfique de coupler ce type de représentation à une représentation choroplèthe (pour comprendre le sens des discontinuités). Ces cartes ne sont pas évidentes à paramétrer. Le choix des critères (seuil, type de différences…) influence fortement la représentation. En fonction du maillage utilisé la lisibilité de la carte peut être faible. Ces représentations sont très puissantes pour montrer les inégalités. La fonctions getBorder() du package cartography permet de construire une couche des frontières terrestres. La fonction discLayer() permet d’afficher les discontinuités. library(sf) library(cartography) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # Get borders mtq_bord &lt;- getBorders(x = mtq) # Plot polygons plot(st_geometry(mtq), border = NA, col = &quot;grey60&quot;) # Plot borders plot(st_geometry(mtq_bord), col = sample(x = rainbow(nrow(mtq_bord))), lwd = 3, add = TRUE) layoutLayer(&quot;Frontières inter-communales&quot;,tabtitle=TRUE, north = TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) mtq$emp_share &lt;- 100 * mtq$C13_CS5/mtq$C13_POP # Plot this share choroLayer( x = mtq, var = &quot;emp_share&quot;, border = NA, method = &#39;quantile&#39;, nclass = 6, legend.values.rnd = 1, legend.pos = &quot;topright&quot;, legend.title.txt = &quot;Part des employés\\ndans la population agée\\nde 15 ans et plus&quot; ) # Plot discontinuities discLayer( x = mtq_bord, df = mtq, var = &quot;emp_share&quot;, col=&quot;darkred&quot;, nclass=3, method=&quot;quantile&quot;, threshold = 0.5, sizemin = 0.5, sizemax = 8, type = &quot;abs&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Discontinuités\\n(différences absolues)&quot;, legend.pos = &quot;bottomleft&quot;, add=TRUE ) layoutLayer(&quot;Discontinuités - Part des employés&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) 3.5 Le lissage spatial L’idée principale du lissage est de filtrer l’information pour révéler des structures spatiales sous-jacentes. C’est un ensemble de méthodes qui consistent à affecter aux points que l’on observe une valeur prenant en compte les valeurs de leur voisinnage. Il existe plusieurs méthodes de lissage (kde, potentiels…) plus ou moins paramétrables. Cette méthode permet de passer représentations ponctuelles à une représentation continu Il est difficile de paramétrer correctement les fonctions de lissages. Elles doivent s’appuyer sur des hypothèses de comportement dans l’espace. La compréhension par un public large n’est pas évidente, il faut alors simplifier les légendes, la présentation de la méthode. Permet de faire ressortir des phénomènes spatiaux sous-jacents invisibles directement. Les cartes produites attirent l’oeil par leur originalité. Cette méthode permet de passer d’une représentation ponctuelle ou discontinue (dans un maillage) à une représentation continue s’affranchissant des maillages existants. 3.5.1 KDE library(sf) library(spatstat) library(maptools) library(raster) # Import des données mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;, quiet = TRUE) sigma = 1000 res = 200 # Define an observation window w &lt;- as.owin(as(mtq, &quot;Spatial&quot;)) # sf to coords pts &lt;- st_coordinates(resto) # Coords to ppp p &lt;- ppp(pts[,1], pts[,2], window=w) # Compute KDE dens &lt;- density.ppp(p, sigma = sigma, eps = res) # Image to raster (+ proj &amp; km2) result &lt;- raster(dens, crs = st_crs(resto)[[2]]) * 1000000 # compute breaks bks &lt;- unique(getBreaks(values(result), nclass = 8, method = &quot;arith&quot;)) # Color ramp cols &lt;- mapview::mapviewGetOption(&quot;raster.palette&quot;)(10)[2:9] # Plot the map plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) plot(result, breaks = bks, col=cols, add = T,legend=F) plot(resto$geom, add=T, pch = 20, cex = 0.01, col = &quot;white&quot;) legendChoro( pos = &quot;topright&quot;, title.txt = &quot;Densité de\\nrestaurants\\n(N./km2)&quot;, breaks = bks, nodata = FALSE, values.rnd = 1, col = cols ) layoutLayer(title = &quot;Répartition des restaurants&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016 - OSM, 2018&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) 3.5.2 Stewart Vignette du package SpatialPosition 3.6 3D 3.6.1 linemap library(linemap) library(sf) data(&quot;popOcc&quot;) data(&quot;occitanie&quot;) opar &lt;- par(mar=c(0,0,0,0), bg = &quot;ivory2&quot;) bb &lt;- st_bbox(occitanie) plot(st_geometry(occitanie), col=&quot;ivory1&quot;, border = NA) linemap( x = popOcc, var = &quot;pop&quot;, k = 2.5, threshold = 50, col = &quot;ivory1&quot;, border = &quot;ivory4&quot;, lwd = 0.6, add = TRUE ) text(x = bb[1], y = bb[4],adj = c(0,1), labels = &quot;Répartition de la\\npopulation\\nen Occitanie&quot;, col = &quot;ivory4&quot;, font = 2, cex = 1.8) # add sources mapsources &lt;-&quot;Timothée Giraud\\nR 3.4.1, cartography 2.0.0, linemap 0.1.0\\nDonnées carroyées à 1 kilomètre, INSEE 2010&quot; text(x = bb[3], y = bb[2],labels = mapsources, col = &quot;ivory4&quot;, font = 3, adj = c(1,0), cex = 0.6 ) 3.6.2 Tanaka library(raster) library(cartography) library(sf) library(SpatialPosition) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE)# use WGS84 proj mtq_latlon &lt;- st_transform(mtq, 4326) # import raster ras &lt;- raster(&quot;data/srtm_24_10.tif&quot;) # crop on martinique area mtq_ras &lt;- crop(ras, st_bbox(mtq_latlon)[c(1,3,2,4)]) # aggregate the raster mtq_ras &lt;- aggregate(mtq_ras, fact=4,fun=mean) mtq_ras &lt;- projectRaster(mtq_ras, crs=st_crs(mtq)$proj4string) # break values bv &lt;- c(seq(0,1300,100),1339) # contour extraction mtq_cont &lt;- rasterToContourPoly(r = mtq_ras, breaks = bv, mask = as(mtq, &quot;Spatial&quot;)) # custom palette pal &lt;- c(&quot;#5D9D52&quot;, &quot;#8DBC80&quot;, &quot;#B8D9A9&quot;, &quot;#FDEBBE&quot;, &quot;#F7E0AC&quot;, &quot;#F2D69B&quot;, &quot;#EDCC8A&quot;, &quot;#E8C279&quot;, &quot;#E2B563&quot;, &quot;#DBA84C&quot;, &quot;#D49B36&quot;, &quot;#BA8428&quot;, &quot;#9A6A1E&quot;, &quot;#7B5114&quot;) # sp to sf k &lt;- st_as_sf(mtq_cont) # order the sf k &lt;- k[order(k$center),] # png(filename = &quot;mtq.png&quot;, width = 700, height = 800, res = 100, bg = NA) plot(st_geometry(mtq), col = NA, border = NA, bg = &quot;lightblue&quot;) for(i in 1:nrow(k)){ p &lt;- st_geometry(k[i,]) plot(p + c(-50, 50), add=T, border = &quot;#ffffff90&quot;,col = &quot;#ffffff90&quot;) plot(p + c(100, -100), col = &quot;#00000090&quot;, add=T, border = &quot;#00000090&quot;) plot(p, col = pal[i], border = &quot;NA&quot;, add=T) } legendChoro(pos = c(689000,1598000 ), breaks = bv, col = pal, nodata = F, title.txt = &quot;Elevation\\n(metres)&quot;, cex = 1) layoutLayer(title = &quot;Martinique Relief&quot;, north = T, sources = &#39;T. Giraud, 2018&#39;, author = &quot;SRTM, 2018&quot;, col = &quot;lightblue&quot;, tabtitle = T, coltitle = &quot;black&quot;) 3.6.3 Rayshader library(sf) library(raster) library(rayshader) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) st_geometry(mtq) &lt;- st_buffer(st_geometry(mtq), 5000) mtq_latlon &lt;- st_transform(mtq, 4326) ras &lt;- raster(&quot;data/srtm_24_10.tif&quot;) mtq_ras &lt;- crop(ras, st_bbox(mtq_latlon)[c(1,3,2,4)]) mtq_ras &lt;- projectRaster(mtq_ras, crs=st_crs(mtq)$proj4string) elmat = matrix(extract(mtq_ras,extent(mtq_ras),buffer=1000), nrow=ncol(mtq_ras),ncol=nrow(mtq_ras)) elmat[is.na(elmat)] &lt;- 0 raymat = ray_shade(elmat,lambert = TRUE,anglebreaks = 85,sunangle = 125) ambmat = ambient_shade(elmat,anglebreaks = 85) elmat %&gt;% sphere_shade(texture = &quot;imhof1&quot;,sunangle = 125) %&gt;% add_water(detect_water(elmat), color=&quot;desert&quot;) %&gt;% add_shadow(raymat,0.5) %&gt;% add_shadow(ambmat,0.5) %&gt;% plot_3d(elmat,zscale=25,fov=10,theta=-15,phi=70, background=&quot;black&quot;, zoom=.5, windowsize =c(900, 900)) References "],
["sessioninfo.html", "Chapitre 4 sessionInfo()", " Chapitre 4 sessionInfo() R version 3.5.2 (2018-12-20) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Debian GNU/Linux 9 (stretch) Matrix products: default BLAS: /usr/lib/libblas/libblas.so.3.7.0 LAPACK: /usr/lib/lapack/liblapack.so.3.7.0 locale: [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C LC_TIME=fr_FR.UTF-8 [4] LC_COLLATE=fr_FR.UTF-8 LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C LC_ADDRESS=C [10] LC_TELEPHONE=C LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] SpatialPosition_1.2.0 linemap_0.1.0 raster_2.8-4 [4] maptools_0.9-4 sp_1.3-1 spatstat_1.57-1 [7] rpart_4.1-13 nlme_3.1-137 spatstat.data_1.4-0 [10] cartogram_0.1.1 mapview_2.6.3 mapinsetr_0.3.0 [13] cartography_2.1.3 dplyr_0.7.8 sf_0.7-2 [16] knitr_1.21 loaded via a namespace (and not attached): [1] jsonlite_1.6 viridisLite_0.3.0 shiny_1.2.0 [4] assertthat_0.2.0 stats4_3.5.2 yaml_2.2.0 [7] pillar_1.3.1 lattice_0.20-38 glue_1.3.0 [10] digest_0.6.18 RColorBrewer_1.1-2 promises_1.0.1 [13] polyclip_1.9-1 colorspace_1.3-2 htmltools_0.3.6 [16] httpuv_1.4.5.1 Matrix_1.2-15 pkgconfig_2.0.2 [19] bookdown_0.9 purrr_0.2.5 xtable_1.8-3 [22] scales_1.0.0 webshot_0.5.1 tensor_1.5 [25] jpeg_0.1-8 satellite_1.0.1 later_0.7.5 [28] spatstat.utils_1.13-0 tibble_2.0.0 mgcv_1.8-26 [31] magrittr_1.5 crayon_1.3.4 mime_0.6 [34] deldir_0.1-16 evaluate_0.12 foreign_0.8-71 [37] class_7.3-14 tools_3.5.2 stringr_1.3.1 [40] munsell_0.5.0 bindrcpp_0.2.2 compiler_3.5.2 [43] e1071_1.7-0 rlang_0.3.0.1 classInt_0.3-1 [46] units_0.6-2 grid_3.5.2 rstudioapi_0.8 [49] htmlwidgets_1.3 goftest_1.1-1 crosstalk_1.0.0 [52] base64enc_0.1-3 rmarkdown_1.11 codetools_0.2-15 [55] abind_1.4-5 DBI_1.0.0 R6_2.3.0 [58] rgdal_1.3-6 rgeos_0.4-2 bindr_0.1.1 [61] stringi_1.2.4 Rcpp_1.0.0 png_0.1-7 [64] leaflet_2.0.2 tidyselect_0.2.5 xfun_0.4 "],
["references.html", "References", " References "]
]
