[
["index.html", "Cartographie avec R Introduction", " Cartographie avec R Timothée Giraud &amp; Hugues Pécout 2018-12-14 Introduction Toute carte est issue d’un processus complexe, de choix, de selections, d’opérations statistiques ou de géotraitements. Certains auteurs énoncent que les cartes sont subjectives (Brunet) et d’autres auteurs disent carrément qu’elles mentent (Monmonnier). Toute carte résulte des choix de son auteur. Dans une démarche scientifique, ces choix doivent être traçables, partageables et soumis à la discussion scientifique et cela est difficilement faisable quand ces cartes sont réalisées dans un environnement “clic-bouton”. La réalisation des cartes dans le langage R permet de tracer toutes les opérations nécessaires à une réalisation cartographique de qualité. Réaliser des cartes dans ce langage unique permet, en diffusant le code source en même temps que les cartes, de jouer “cartes sur table”. Cela permet de détailler les choix qui ont été faits et s’exposer à la controverse scientifique. Cela permet aussi de travailler à plusieurs sur une carte, en associant des compétences complémentaires (sémiologie graphique, statistique, géomatique, etc.) et de faciliter la mise à jour de documents déjà réalisés. Ce document se compose de trois parties permettant d’appréhender la création de cartes thématiques avec R. Les données spatiales Cartographie thématique Cartographie thématique avancée Ce document mobilise un certain nombre de packages dédiés à l’import, la manipulation, la transformation et l’affichage de données spatiales. Les principaux packages sont sf, cartography, mapview, raster, SpatialPosition, spatstats mais d’autres pourront être nécessaires ponctuellement. "],
["chapitre1.html", "Chapitre 1 Les données spatiales 1.1 Le package sf 1.2 Les projections 1.3 Opérations de géotraitement 1.4 Géocodage d’adresses 1.5 Le package raster", " Chapitre 1 Les données spatiales Il est possible d’importer, de manipuler, de traiter, d’afficher et d’exporter des données spatiales avec R. La grande majorité des opérations de géotraitement sont disponible dans R grace au package sf. Il devient alors possible d’utiliser R comme un SIG. 1.1 Le package sf Historique Historiquement trois packages permettent d’importer, de manipuler et de transformer les données spatiales : Le package rgdal qui est une interface entre R et les librairies GDAL (Geospatial Data Abstraction Library) et PROJ4 permet d’importer et d’exporter les données spatiales (les shapefiles par exemple) et aussi de gérer les projections cartographiques Le package sp fournit des classes et methodes pour les données spatiales dans R. C’est grace à ce package que l’on peut afficher des fond de cartes, inspecter une table attributaire etc. Le package rgeos donne accès à la librairie d’opérations spatiales GEOS (Geometry Engine - Open Source) et rend donc disponible les opérations SIG classiques : calcul de surface ou de périmètre, calcul de distances, aggrégations spatiales, zones tampons, intersections etc. La suite Le package sf a été publié fin 2016 par Edzer Pebesma (auteur de sp). Son objectif est de combiner dans les fonctionnalités de sp, rgeos et rgdal dans un package unique plus ergonomique. Ce package propose des objets plus simples (suivant le standard simple feature) dont la manipulation est plus aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe et les opérateurs du tidyverse. Aujourd’hui, les principaux développements dans l’écosystème spatial de R se détachent progressivement des 3 anciens (sp, rgdal, rgeos) pour se reposer sur sf. Dans ce document nous utiliserons sf tant que cela est possible, c’està dire la plupart du temps. 1.1.1 Format des objets spatiaux sf Les objets sf sont des data.frame dont l’une des colonne contient des géométrie. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry). Ce format très pratique dans la mesure ou les données et les géométries sont intrinsequement liées dans un même objet. 1.1.2 Construction d’un objet sf 1.1.2.1 Couche de points pt1_sfg &lt;- st_point(c(1,2)) pt2_sfg &lt;- st_point(c(3,4)) pt3_sfg &lt;- st_point(c(2,1)) (pt_sfc &lt;- st_sfc(pt1_sfg,pt2_sfg,pt3_sfg, crs = (4326))) Geometry set for 3 features geometry type: POINT dimension: XY bbox: xmin: 1 ymin: 1 xmax: 3 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs pt_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (pt_sf &lt;- st_sf(pt_df,geometry = pt_sfc)) Simple feature collection with 3 features and 4 fields geometry type: POINT dimension: XY bbox: xmin: 1 ymin: 1 xmax: 3 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs id cat var1 var2 geometry 1 1 A 10 2.3 POINT (1 2) 2 2 B 20 1.9 POINT (3 4) 3 3 A 30 4.0 POINT (2 1) plot(pt_sf) 1.1.2.2 Couche de polygones p1 &lt;- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)) p2 &lt;- rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0)) p3 &lt;- rbind(c(3,3), c(4,2), c(4,3), c(3,3)) pol1_sfg &lt;-st_polygon(list(p1)) pol2_sfg &lt;-st_polygon(list(p2)) pol3_sfg &lt;-st_polygon(list(p3)) (pol_sfc &lt;- st_sfc(pol1_sfg, pol2_sfg, pol3_sfg, crs = 4326)) Geometry set for 3 features geometry type: POLYGON dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs pol_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (pol_sf &lt;- st_sf(pol_df,geometry = pol_sfc)) Simple feature collection with 3 features and 4 fields geometry type: POLYGON dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs id cat var1 var2 geometry 1 1 A 10 2.3 POLYGON ((0 0, 1 0, 3 2, 2 ... 2 2 B 20 1.9 POLYGON ((3 0, 4 0, 4 1, 3 ... 3 3 A 30 4.0 POLYGON ((3 3, 4 2, 4 3, 3 3)) plot(pol_sf) 1.1.2.3 Couche de linestring p1 &lt;- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4)) p2 &lt;- rbind(c(3,0), c(4,0), c(4,1), c(3,1)) p3 &lt;- rbind(c(3,3), c(4,2), c(4,3)) ls1_sfg &lt;-st_linestring(p1) ls2_sfg &lt;-st_linestring(p2) ls3_sfg &lt;-st_linestring(p3) (ls_sfc &lt;- st_sfc(ls1_sfg, ls2_sfg, ls3_sfg, crs = 4326)) Geometry set for 3 features geometry type: LINESTRING dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs ls_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (ls_sf &lt;- st_sf(ls_df,geometry = ls_sfc)) Simple feature collection with 3 features and 4 fields geometry type: LINESTRING dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 epsg (SRID): 4326 proj4string: +proj=longlat +datum=WGS84 +no_defs id cat var1 var2 geometry 1 1 A 10 2.3 LINESTRING (0 0, 1 0, 3 2, ... 2 2 B 20 1.9 LINESTRING (3 0, 4 0, 4 1, ... 3 3 A 30 4.0 LINESTRING (3 3, 4 2, 4 3) plot(ls_sf) 1.1.3 Import / Export library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;) Reading layer `martinique&#39; from data source `/home/tim/Documents/prz/Cartographie_avec_R/data/martinique.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 34 features and 23 fields geometry type: POLYGON dimension: XY bbox: xmin: 690574.4 ymin: 1592426 xmax: 736126.5 ymax: 1645660 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs st_write(obj = mtq, dsn = &quot;data/mtq.gpkg&quot;, layer = &quot;mtq&quot;, delete_layer = TRUE) Deleting layer `mtq&#39; failed Updating layer `mtq&#39; to data source `data/mtq.gpkg&#39; using driver `GPKG&#39; features: 34 fields: 23 geometry type: Polygon st_write(obj = mtq, &quot;data/mtq.shp&quot;, delete_layer = T) Writing layer `mtq&#39; to data source `data/mtq.shp&#39; using driver `ESRI Shapefile&#39; features: 34 fields: 23 geometry type: Polygon 1.1.4 Affichage de données Aperçu des variables plot(mtq) Affichage de la géométrie plot(st_geometry(mtq)) 1.1.5 Joindre des données 1.2 Les projections 1.3 Opérations de géotraitement 1.3.1 Selection par attributs 1.3.2 Selection spatiale 1.3.3 Extraire des centroides mtq_c &lt;- st_centroid(mtq) plot(st_geometry(mtq)) plot(st_geometry(mtq_c), add=TRUE, cex=1.2, col=&quot;red&quot;, pch=20) 1.3.4 Créer une matrice de distances mat &lt;- st_distance(x=mtq_c,y=mtq_c) mat[1:5,1:5] Units: [m] [,1] [,2] [,3] [,4] [,5] [1,] 0.000 35297.56 3091.501 12131.617 17136.310 [2,] 35297.557 0.00 38332.602 25518.913 18605.249 [3,] 3091.501 38332.60 0.000 15094.702 20226.198 [4,] 12131.617 25518.91 15094.702 0.000 7177.011 [5,] 17136.310 18605.25 20226.198 7177.011 0.000 1.3.5 Agréger des polygones mtq_u &lt;- st_union(mtq) plot(st_geometry(mtq), col=&quot;lightblue&quot;) plot(st_geometry(mtq_u), add=T, lwd=2, border = &quot;red&quot;) 1.3.6 Agréger des polygones en fonction d’une variable 1.3.7 Construire une zone tampon mtq_b &lt;- st_buffer(x = mtq_u, dist = 2000) plot(st_geometry(mtq), col=&quot;lightblue&quot;) plot(st_geometry(mtq_u), add=T, lwd=2) plot(st_geometry(mtq_b), add=T, lwd=2, border = &quot;red&quot;) 1.3.8 Réaliser une intersection m &lt;- rbind(c(700015,1624212), c(700015,1641586), c(719127,1641586), c(719127,1624212), c(700015,1624212)) p &lt;- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq)) plot(st_geometry(mtq)) plot(p, border=&quot;red&quot;, lwd=2, add=T) mtq_z &lt;- st_intersection(x = mtq, y = p) plot(st_geometry(mtq)) plot(st_geometry(mtq_z), col=&quot;red&quot;, border=&quot;green&quot;, add=T) plot(st_geometry(mtq_z)) 1.3.9 Construire des polygones de Voronoi google: “st_voronoi R sf” (https://github.com/r-spatial/sf/issues/474 &amp; https://stackoverflow.com/questions/45719790/create-voronoi-polygon-with-simple-feature-in-r) mtq_v &lt;- st_voronoi(x = st_union(mtq_c)) mtq_v &lt;- st_intersection(st_cast(mtq_v), st_union(mtq)) mtq_v &lt;- st_join(x = st_sf(mtq_v), y = mtq_c, join=st_intersects) mtq_v &lt;- st_cast(mtq_v, &quot;MULTIPOLYGON&quot;) plot(st_geometry(mtq_v), col=&#39;lightblue&#39;) 1.3.10 Exemple Découpe d’une zone par un polygone 1.4 Géocodage d’adresses 1.5 Le package raster "],
["chapitre2.html", "Chapitre 2 Cartographie thématique 2.1 Le package cartography 2.2 Représentations usuelles 2.3 Éléments d’habillage 2.4 Palettes de couleurs 2.5 Discrétisations 2.6 Combinaisons 2.7 Les données OSM 2.8 Création de cartons", " Chapitre 2 Cartographie thématique 2.1 Le package cartography Le package cartography (Giraud and Lambert 2018) permet de créer et intégrer des cartes thématiques dans sa chaîne de traitements en R. Il permet des représentations cartographiques tels que les cartes en symboles proportionnels, des cartes choroplèthes, des typologies, des cartes de flux ou des cartes de discontinuités. Il offre également des fonctions qui permettent d’améliorer la réalisation de la carte, comme des palettes de couleur, des éléments d’habillage (échelle, flèche du nord, titre, légende…), d’y rattacher des labels ou d’accéder à des APIs cartographiques. Pour utiliser aisément ce package, plusieurs sources d’intérêts peuvent être consultées : La documentation du package accessible directement dans R : ?cartography La vignette associée au package présente des exemples de scripts vignette(&quot;cartography&quot;) Le blog R Géomatique met à disposition ressources et exemples liés au package et plus généralement à l’écosystème spatiale de R. La cheat sheet de cartography, qui résume les principales fonctions du package de façon synthétique. 2.2 Représentations usuelles 2.2.1 Symboles proportionnels library(cartography) library(sf) # Import des données mtq &lt;- st_read(system.file(&quot;shape/martinique.shp&quot;, package=&quot;cartography&quot;)) Reading layer `martinique&#39; from data source `/home/tim/Documents/lib/R/library/cartography/shape/martinique.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 34 features and 23 fields geometry type: POLYGON dimension: XY bbox: xmin: 690574.4 ymin: 1592426 xmax: 736126.5 ymax: 1645660 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs # Communes plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) # Symboles proportionnels propSymbolsLayer(x = mtq, var = &quot;P13_POP&quot;, legend.title.txt = &quot;Total\\npopulation (2013)&quot;) # Titre title(main = &quot;Population en Martinique&quot;) 2.2.2 Carte choroplèthe mtq$cagr &lt;- (((mtq$P13_POP / mtq$P08_POP)^(1/4)) - 1) * 100 choroLayer(x = mtq, var = &quot;cagr&quot;, breaks = c(-6.14,-2,-1,0,1,2), col = c(&quot;#135D89&quot;, &quot;#4D95BA&quot;, &quot;#96D1EA&quot;, &quot;#FCDACA&quot;, &quot;#EC4E49&quot;), legend.title.txt = &quot;Compound annual\\ngrowth rate&quot;) title(main = &quot;Evolution de la population&quot;) 2.3 Éléments d’habillage Titre, sources, auteur, Flèche nord, échelle plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) layoutLayer(title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2018&quot;, col =&quot;grey20&quot;, coltitle = &quot;red&quot;, tabtitle = TRUE, frame = FALSE, scale = NULL) north(pos = &quot;topright&quot;, col = &quot;red&quot;) barscale(size = 5, lwd = 1.2, cex = 0.8) plot(st_geometry(mtq), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, bg = &quot;#A6CAE0&quot;) labelLayer(x = mtq, txt = &quot;LIBGEO&quot;, col= &quot;black&quot;, cex = 0.7, font = 4, halo = TRUE, bg = &quot;white&quot;, r = 0.1, overlap = FALSE, show.lines = FALSE) 2.4 Palettes de couleurs display.carto.all(20) display.carto.pal(&quot;orange.pal&quot;) mypal &lt;- carto.pal(pal1 = &quot;wine.pal&quot;, n1 = 7, pal2 = &quot;green.pal&quot;, n2 = 12, middle = TRUE, transparency = TRUE) k &lt;- length(mypal) image(1:k, 1, as.matrix(1:k), col=mypal, xlab = paste(k,&quot; classes&quot;,sep=&quot;&quot;), ylab = &quot;&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;,bty = &quot;n&quot;) 2.5 Discrétisations var &lt;- mtq$cagr moy &lt;- mean(var) med &lt;- median(var) std &lt;- sd(var) # Quantile intervals breaks &lt;- getBreaks(v = var, nclass = 6, method = &quot;quantile&quot;) hist(var, probability = TRUE, breaks = breaks, main=&quot;quantiles&quot;, col = carto.pal(pal1 = &quot;wine.pal&quot;,3, &quot;green.pal&quot;, 3)) rug(var) abline(v = med, col = &quot;blue&quot;, lwd = 3) # Mean and standard deviation (msd) breaks &lt;- getBreaks(v = var, method = &quot;msd&quot;, k = 1, middle = TRUE) hist(var, probability = TRUE, breaks = breaks, main=&quot;moyenne / écart-type&quot;, col = carto.pal(pal1 = &quot;wine.pal&quot;,3 , &quot;green.pal&quot;, 2, middle = TRUE)) rug(var) abline(v = moy, col = &quot;red&quot;, lwd = 3) abline(v = moy + 0.5 * std, col = &quot;blue&quot;, lwd = 3) abline(v = moy - 0.5 * std, col = &quot;blue&quot;, lwd = 3) 2.6 Combinaisons plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) propSymbolsChoroLayer(x = mtq, var= &quot;P13_POP&quot;, legend.var.title.txt = &quot;Total\\npopulation (2013)&quot;, var2 = &quot;cagr&quot;, legend.var.pos = &quot;bottomleft&quot;, breaks = c(-6.14,-2,-1,0,1,2), col = c(&quot;#135D89&quot;, &quot;#4D95BA&quot;, &quot;#96D1EA&quot;, &quot;#FCDACA&quot;, &quot;#EC4E49&quot;), legend.var2.title.txt = &quot;Compound annual\\ngrowth rate&quot;) # Title title(main = &quot;Evolution de la population&quot;) 2.7 Les données OSM OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le Monde entier. En résumé, c’est comme Google Maps, mais en mieux… 2.7.1 Données vectorielles library(&quot;osmdata&quot;) q &lt;- opq(bbox=st_bbox(st_transform(mtq,4326))) q1 &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;restaurant&quot; ) res &lt;- osmdata_sf(q1) restau1 &lt;- res$osm_points[!is.na(res$osm_points$amenity),] restau2 &lt;- res$osm_polygons st_geometry(restau2) &lt;- st_centroid(st_geometry(restau2)) q1 &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;fast_food&quot; ) res &lt;- osmdata_sf(q1) fast1 &lt;- res$osm_points[!is.na(res$osm_points$amenity),] fast2 &lt;- res$osm_polygons st_geometry(fast2) &lt;- st_centroid(st_geometry(fast2)) q1 &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;cafe&quot; ) res &lt;- osmdata_sf(q1) cafe1 &lt;- res$osm_points[!is.na(res$osm_points$amenity),] cafe2 &lt;- res$osm_polygons st_geometry(cafe2) &lt;- st_centroid(st_geometry(cafe2)) osm_restau &lt;- rbind(restau1[, c(&quot;osm_id&quot;, &quot;name&quot;)], restau2[, c(&quot;osm_id&quot;, &quot;name&quot;)], fast1[, c(&quot;osm_id&quot;, &quot;name&quot;)], fast2[, c(&quot;osm_id&quot;, &quot;name&quot;)], cafe1[, c(&quot;osm_id&quot;, &quot;name&quot;)], cafe2[, c(&quot;osm_id&quot;, &quot;name&quot;)]) osm_restau &lt;- st_transform(osm_restau, st_crs(mtq)) plot(osm_restau) plot(mtq$geometry) plot(osm_restau$geometry,add=T, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) labelLayer(osm_restau, txt = &quot;name&quot;, overlap = F,show.lines = F, ) # st_write(osm_restau, dsn = &quot;data/resto.gpkg&quot;) 2.7.2 Données raster tiles &lt;- getTiles(x = mtq, type = &quot;osm&quot;, crop=T, zoom = 11) tilesLayer(tiles) plot(st_geometry(mtq), add=T) 2.8 Création de cartons References "],
["chapitre3.html", "Chapitre 3 Cartographie thématique avancée 3.1 Cartographie interactiv 3.2 Les cartogrammes 3.3 Les grilles régulières 3.4 Les cartes de discontinuités 3.5 Le lissage spatial 3.6 3D", " Chapitre 3 Cartographie thématique avancée 3.1 Cartographie interactiv mapview mtq &lt;- st_read(system.file(&quot;shape/martinique.shp&quot;, package=&quot;cartography&quot;)) Reading layer `martinique&#39; from data source `/home/tim/Documents/lib/R/library/cartography/shape/martinique.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 34 features and 23 fields geometry type: POLYGON dimension: XY bbox: xmin: 690574.4 ymin: 1592426 xmax: 736126.5 ymax: 1645660 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;) Reading layer `resto&#39; from data source `/home/tim/Documents/prz/carto_avec_r/data/resto.gpkg&#39; using driver `GPKG&#39; Simple feature collection with 362 features and 2 fields geometry type: POINT dimension: XY bbox: xmin: 695535.4 ymin: 1592795 xmax: 734337.5 ymax: 1644743 epsg (SRID): 32620 proj4string: +proj=utm +zone=20 +datum=WGS84 +units=m +no_defs library(mapview) ?mapview mapview(resto, map.types = &quot;OpenStreetMap&quot;, col.regions = &quot;#940000&quot;, label = resto$name,alpha.regions=90, color = &quot;white&quot;, legend = TRUE, layer.name = &quot;Resto&quot;, homebutton = FALSE, lwd = 0.5) + mapview(mtq, col.regions = &quot;#000094&quot;, color = &quot;white&quot;, legend = TRUE, label = mtq$LIBGEO, alpha.regions= 0.2, map.types = &quot;OpenStreetMap&quot;, lwd = 0.5, layer.name = &quot;Communes&quot;, homebutton = FALSE) 3.2 Les cartogrammes L’anamorphose classique est une représentation des États (ou de mailles quelconques) par des rectangles ou des polygones quelconques en fonction d’une quantité qui leur est rattaché. (…) On s’efforce de garder l’arrangement général des mailles ou la silhouette du continent.&quot; Brunet, Ferras, and Théry (1993) Nous aborderons ici 3 types d’anamorphoses ou cartogrammes : Les cartogrammes de Dorling (Dorling 1996) Les cartogrammes non contigus (Olson 1976) Les cartogrammes contigus (Dougenik, Chrisman, and Niemeyer 1985) Vous trouverez un cours complet sur les anamorphoses ici : Les anamorphoses cartographiques (Lambert 2015) 3.2.1 Les cartogrammes de Dorling Les territoires sont représentés par des figurés (cercles, des carrés ou des rectangles) ne se recouvrant pas dont les surfaces sont proportionnelle à une variable. Les positions des figurés sont définie selon les positions de départ. (McCormick 2017) On identifie assez mal l’espace. On peut nommer les cercles pour se repérer et/ou s’aider de la couleur pour faire apparaitre des clusters et mieux identifier les blocks géographiques. La perception des quantités est très bonne. Les tailles de cercles sont vraiment comparables. 3.2.2 Les cartogrammes non continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. La forme des polygones est ressemblante. (Cauvin, Escobar, and Serradj 2013) La topologie des régions est perdue. La conservation de la forme des polygones est optimale. 3.2.3 Les cartogrammes continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. Pour conserver la contiguité, la forme des polygones est fortement transformée. (Paull and Hennig 2016) La forme des polygones est fortement distordue. C’est une “vraie carte de géographie” : la topologie et la contiguité sont conservées. 3.2.4 Forces et faiblesses des cartogrammes Les cartogrammes sont des représentations cartographiques perçues comme innovante (bien que la methode date de 40 ans). Ces images très généralisées rendent bien compte des quantités et des gradiants. Ce sont de vraies images de communication qui provoquent, suscitent l’intérêt, véhiculent un message fort, interpellent. Mais les cartogrammes induisent une perte des repères visuels (difficile de retrouver son pays, ou sa région sur la carte), demandent un effort de lecture qui peut être important et ne permettent pas de gérer des données manquantes. 3.3 Les grilles régulières La méthode du carroyage consiste à découper l’espace géographique en un maillage formé de carrés réguliers dans une projection donnée. La donnée est répartie sur ce quadrillage régulier au prorata de la surface représentée. Le quadrillage permet ainsi de s’affranchir des mailles administratives. Ces représentation induisent une perte de précision. Les maillages produit n’ont pas de signification. La version simple (les valeurs sont redistribuées au prorata de la surface), implique une equirépartition du phénomène dans chaque unités. La comparaison de maillages différents, à plusieurs dates ou de différentes sources est rendue possible. La fonction getGridLayer du package cartography permet de construire ces grilles régulières. 3.4 Les cartes de discontinuités Ce type de représentation permet de souligner cartographiquement les discontinuités territoriales d’un phénomène. L’accent est porter sur ce qui distingue des territoires. Pour chaque frontière nous calculons le rapports ou la différence des valeurs des polygones de part et d’autre. Puis nous représentons la frontière par un figuré d’autant plus épais que la différence est forte. Il est souvent bénéfique de coupler ce type de représentation à une représentation choroplèthe (pour comprendre le sens des discontinuités). Ces cartes ne sont pas évidentes à paramétrer. Le choix des critères (seuil, type de différences…) influence fortement la représentation. En fonction du maillage utilisé la lisibilité de la carte peut être faible. Ces représentations sont très puissantes pour montrer les inégalités. 3.5 Le lissage spatial L’idée principale du lissage est de filtrer l’information pour révéler des structures spatiales sous-jacentes. C’est un ensemble de méthodes qui consistent à affecter aux points que l’on observe une valeur prenant en compte les valeurs de leur voisinnage. Il existe plusieurs méthodes de lissage (kde, potentiels…) plus ou moins paramétrables. Cette méthode permet de passer représentations ponctuelles à une représentation continu Il est difficile de paramétrer correctement les fonctions de lissages. Elles doivent s’appuyer sur des hypothèses de comportement dans l’espace. La compréhension par un public large n’est pas évidente, il faut alors simplifier les légendes, la présentation de la méthode. Permet de faire ressortir des phénomènes spatiaux sous-jacents invisibles directement. Les cartes produites attirent l’oeil par leur originalité. Cette méthode permet de passer d’une représentation ponctuelle ou discontinue (dans un maillage) à une représentation continue s’affranchissant des maillages existants. 3.5.1 KDE library(sf) library(spatstat) library(maptools) library(raster) # Import des données mtq &lt;- st_read(system.file(&quot;shape/martinique.shp&quot;, package=&quot;cartography&quot;)) # Communes resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;) sigma = 1000 res = 200 # Define an observation window w &lt;- as.owin(as(mtq, &quot;Spatial&quot;)) # sf to coords pts &lt;- st_coordinates(resto) # Coords to ppp p &lt;- ppp(pts[,1], pts[,2], window=w) # Compute KDE dens &lt;- density.ppp(p, sigma = sigma, eps = res) # Image to raster (+ proj &amp; km2) result &lt;- raster(dens, crs = st_crs(resto)[[2]]) * 1000000 # compute breaks bks &lt;- unique(getBreaks(values(result), nclass = 8, method = &quot;arith&quot;)) # Color ramp cols &lt;- mapview::mapviewGetOption(&quot;raster.palette&quot;)(10)[2:9] # Plot the map plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) plot(result, breaks = bks, col=cols, add = T,legend=F) plot(resto$geom, add=T, pch = 20, cex = 0.01, col = &quot;white&quot;) legendChoro(pos = &quot;topright&quot;, cex = 0.8, title.txt = &quot;Resto Density&quot;,values.cex = 0.6, breaks = bks, nodata = FALSE,values.rnd = 1, col = cols) layoutLayer(title = &quot;DKE RESTO&quot;, scale = 5, tabtitle = TRUE, frame = FALSE, author = &quot;TG &amp; HP&quot;, sources = &quot;IGN &amp; OSM&quot;) 3.5.2 Stewart Vignette du package SpatialPosition 3.6 3D 3.6.1 linemap library(linemap) library(sf) data(&quot;popOcc&quot;) data(&quot;occitanie&quot;) opar &lt;- par(mar=c(0,0,0,0), bg = &quot;ivory2&quot;) bb &lt;- st_bbox(occitanie) plot(st_geometry(occitanie), col=&quot;ivory1&quot;, border = NA) linemap(x = popOcc, var = &quot;pop&quot;, k = 2.5, threshold = 50, col = &quot;ivory1&quot;, border = &quot;ivory4&quot;, lwd = 0.6, add = TRUE) text(x = bb[1], y = bb[4],adj = c(0,1), labels = &quot;Répartition de la\\npopulation\\nen Occitanie&quot;, col = &quot;ivory4&quot;, font = 2, cex = 1.8) # add sources mapsources &lt;-&quot;Timothée Giraud\\nR 3.4.1, cartography 2.0.0, linemap 0.1.0\\nDonnées carroyées à 1 kilomètre, INSEE 2010&quot; text(x = bb[3], y = bb[2],labels = mapsources, col = &quot;ivory4&quot;, font = 3, adj = c(1,0), cex = 0.6 ) 3.6.2 rayshader References "],
["sessioninfo.html", "Chapitre 4 sessionInfo()", " Chapitre 4 sessionInfo() R version 3.5.1 (2018-07-02) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Debian GNU/Linux 9 (stretch) Matrix products: default BLAS: /usr/lib/libblas/libblas.so.3.7.0 LAPACK: /usr/lib/lapack/liblapack.so.3.7.0 locale: [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C LC_TIME=fr_FR.UTF-8 [4] LC_COLLATE=fr_FR.UTF-8 LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C LC_ADDRESS=C [10] LC_TELEPHONE=C LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] mapview_2.6.0 raster_2.8-4 maptools_0.9-4 sp_1.3-1 [5] spatstat_1.57-1 rpart_4.1-13 nlme_3.1-137 spatstat.data_1.4-0 [9] linemap_0.1.0 cartography_2.1.3 sf_0.7-1 knitr_1.21 loaded via a namespace (and not attached): [1] xfun_0.4 lattice_0.20-35 colorspace_1.3-2 [4] spatstat.utils_1.13-0 viridisLite_0.3.0 stats4_3.5.1 [7] htmltools_0.3.6 yaml_2.2.0 mgcv_1.8-24 [10] base64enc_0.1-3 e1071_1.7-0 later_0.7.5 [13] foreign_0.8-70 DBI_1.0.0 jpeg_0.1-8 [16] stringr_1.3.1 rgeos_0.4-2 munsell_0.5.0 [19] htmlwidgets_1.3 codetools_0.2-15 evaluate_0.12 [22] httpuv_1.4.5 crosstalk_1.0.0 class_7.3-14 [25] Rcpp_1.0.0 xtable_1.8-3 tensor_1.5 [28] scales_1.0.0 promises_1.0.1 classInt_0.2-3 [31] satellite_1.0.1 jsonlite_1.6 webshot_0.5.1 [34] leaflet_2.0.2 abind_1.4-5 mime_0.6 [37] deldir_0.1-15 png_0.1-7 digest_0.6.18 [40] stringi_1.2.4 bookdown_0.8 shiny_1.2.0 [43] polyclip_1.9-1 grid_3.5.1 rgdal_1.3-6 [46] tools_3.5.1 magrittr_1.5 goftest_1.1-1 [49] Matrix_1.2-14 spData_0.2.9.6 rmarkdown_1.11 [52] rstudioapi_0.8 R6_2.3.0 units_0.6-2 [55] compiler_3.5.1 "],
["references.html", "References", " References "]
]
