[
["index.html", "Cartographie avec R Introduction", " Cartographie avec R Timothée Giraud1 &amp; Hugues Pecout2 03 juin 2020 Introduction Objectifs Savoir créer et manipuler des données spatiales Savoir créer des cartes thématiques conformes aux règles de la sémiologie graphique et de la cartographie Connaitre des modes de représentation plus complexes Ce document se compose de trois parties permettant d’appréhender la création de cartes thématiques avec R. Les données spatiales Cartographie thématique Cartographie thématique avancée Packages et données Voici les packages dédiés à l’import, la manipulation, la transformation et l’affichage de données spatiales utilisés dans ce document : Depuis le CRAN : banR, cartogram, cartography, linemap, maptools, mapview, osmdata, png, raster, rayshader, sf, spatstat, tanaka. Depuis GitHub : mapinsetr, nominatim, photon. Il faut utiliser le package remotes pour les installer La plupart des exemples du document utilisent un jeu de données du package cartography. Il s’agit des communes du département de la Martinique. Pour l’importer : library(sf) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) Vous pouvez nous envoyer vos remarques et suggestions en postant une issue sur le repo GitHub de ce document. La version en ligne de ce document est sous licence Creative Commons Attribution-NonCommercial-ShareAlike 4.0. Université de Paris, UMS RIATE, CNRS, F-75013 Paris, France↩︎ FR CIST, CNRS, F-75013 Paris, France↩︎ "],
["chapitre1.html", "Chapitre 1 Les données spatiales 1.1 Le package sf 1.2 Les systèmes de projections 1.3 Opérations de géotraitement 1.4 Géocodage d’adresses 1.5 Importer des données OSM 1.6 Exercices", " Chapitre 1 Les données spatiales Il est possible d’importer, de manipuler, de traiter, d’afficher et d’exporter des données spatiales avec R. La grande majorité des opérations de géotraitement sont disponibles dans R grâce au package sf. Il devient alors possible d’utiliser R comme un SIG. 1.1 Le package sf Historique Historiquement, trois packages permettent d’importer, de manipuler et de transformer les données spatiales : Le package rgdal qui est une interface entre R et les librairies GDAL (Geospatial Data Abstraction Library) et PROJ4 permet d’importer et d’exporter les données spatiales (les shapefiles par exemple) et aussi de gérer les projections cartographiques Le package sp fournit des classes et méthodes pour les données spatiales dans R. Il permet afficher des fond de cartes, d’inspecter une table attributaire etc. Le package rgeos donne accès à la librairie d’opérations spatiales GEOS (Geometry Engine - Open Source) et rend donc disponible les opérations SIG classiques : calcul de surface ou de périmètre, calcul de distances, agrégations spatiales, zones tampons, intersections etc. La suite Le package sf ((Pebesma 2018a), (Pebesma 2018b)) a été publié fin 2016 par Edzer Pebesma (également auteur de sp). Son objectif est de combiner les fonctionnalités de sp, rgeos et rgdal dans un package unique plus ergonomique. Ce package propose des objets plus simples (suivant le standard simple feature) dont la manipulation est plus aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe et les opérateurs du tidyverse. Aujourd’hui, les principaux développements dans l’écosystème spatial de R se détachent progressivement des 3 anciens (sp, rgdal, rgeos) pour se reposer sur sf. Site web du package sf 1.1.1 Format des objets spatiaux sf Les objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry). Ce format est très pratique dans la mesure ou les données et les géométries sont intrinsèquement liées dans un même objet. 1.1.2 Import / Export Les fonctions st_read() et st_write() permettent d’importer et d’exporter de nombreux types de fichiers. Les lignes suivantes importent le fichier shapefile de la martinique situé dans un dossier data. library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet=TRUE) Les lignes suivantes exportent l’objet mtq dans un dossier data aux formats geopackage et shapefile. st_write(obj = mtq, dsn = &quot;data/mtq.gpkg&quot;, layer = &quot;mtq&quot;, delete_layer = TRUE) Deleting layer `mtq&#39; using driver `GPKG&#39; Writing layer `mtq&#39; to data source `data/mtq.gpkg&#39; using driver `GPKG&#39; Writing 34 features with 7 fields and geometry type Multi Polygon. st_write(obj = mtq, &quot;data/mtq.shp&quot;, delete_layer = TRUE) Deleting layer `mtq&#39; using driver `ESRI Shapefile&#39; Writing layer `mtq&#39; to data source `data/mtq.shp&#39; using driver `ESRI Shapefile&#39; Writing 34 features with 7 fields and geometry type Multi Polygon. Pour importer le jeu de données proposé dans le package cartography, il faut installer le package puis utiliser le code suivant : install.packages(&quot;cartography&quot;) library(sf) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) 1.1.3 Affichage de données Aperçu des variables via les fonctions head() et plot(). head(mtq) Simple feature collection with 6 features and 7 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 695444 ymin: 1598818 xmax: 717731 ymax: 1645182 CRS: 32620 INSEE_COM STATUS LIBGEO POP MED CHOM ACT 1 97201 Simple municipality L&#39;Ajoupa-Bouillon 1902 13633 254 801 2 97202 Simple municipality Les Anses-d&#39;Arlet 3737 14558 425 1659 3 97203 Simple municipality Basse-Pointe 3357 14456 400 1395 4 97204 Simple municipality Le Carbet 3683 18847 285 1568 5 97205 Simple municipality Case-Pilote 4458 21005 347 2096 6 97206 Simple municipality Le Diamant 5976 19704 430 2654 geom 1 MULTIPOLYGON (((699261 1637... 2 MULTIPOLYGON (((709840 1599... 3 MULTIPOLYGON (((697602 1638... 4 MULTIPOLYGON (((702229 1628... 5 MULTIPOLYGON (((698805 1621... 6 MULTIPOLYGON (((709840 1599... plot(mtq) Affichage de la géométrie uniquement. plot(st_geometry(mtq)) 1.1.4 Joindre des données On peut joindre un data.frame à un objet sf en utilisant la fonction merge(). mtq2016 &lt;- read.csv(file = &quot;data/mtq2016.csv&quot;) head(mtq2016) ID NOM Population.totale 1 97201 L&#39; Ajoupa-Bouillon 1964 2 97202 Les Anses-d&#39;Arlet 3686 3 97203 Basse-Pointe 3238 4 97234 Bellefontaine 1760 5 97204 Le Carbet 3655 6 97205 Case-Pilote 4522 mtq &lt;- merge(x = mtq, y = mtq2016, by.x = &quot;INSEE_COM&quot;, by.y = &quot;ID&quot;) head(mtq) Simple feature collection with 6 features and 9 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 695444 ymin: 1598818 xmax: 717731 ymax: 1645182 CRS: 32620 INSEE_COM STATUS LIBGEO POP MED CHOM ACT NOM 1 97201 Simple municipality L&#39;Ajoupa-Bouillon 1902 13633 254 801 L&#39; Ajoupa-Bouillon 2 97202 Simple municipality Les Anses-d&#39;Arlet 3737 14558 425 1659 Les Anses-d&#39;Arlet 3 97203 Simple municipality Basse-Pointe 3357 14456 400 1395 Basse-Pointe 4 97204 Simple municipality Le Carbet 3683 18847 285 1568 Le Carbet 5 97205 Simple municipality Case-Pilote 4458 21005 347 2096 Case-Pilote 6 97206 Simple municipality Le Diamant 5976 19704 430 2654 Le Diamant Population.totale geometry 1 1964 MULTIPOLYGON (((699261 1637... 2 3686 MULTIPOLYGON (((709840 1599... 3 3238 MULTIPOLYGON (((697602 1638... 4 3655 MULTIPOLYGON (((702229 1628... 5 4522 MULTIPOLYGON (((698805 1621... 6 5886 MULTIPOLYGON (((709840 1599... 1.2 Les systèmes de projections 1.2.1 Consulter la projection d’un objet La fonction st_crs() permet de consulter le système de projection utilisé par un objet sf et de la modifier (sans reprojeter les données). st_crs(mtq) Coordinate Reference System: User input: 32620 wkt: PROJCS[&quot;WGS 84 / UTM zone 20N&quot;, GEOGCS[&quot;WGS 84&quot;, DATUM[&quot;WGS_1984&quot;, SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563, AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]], AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]], PRIMEM[&quot;Greenwich&quot;,0, AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]], UNIT[&quot;degree&quot;,0.0174532925199433, AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]], AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]], PROJECTION[&quot;Transverse_Mercator&quot;], PARAMETER[&quot;latitude_of_origin&quot;,0], PARAMETER[&quot;central_meridian&quot;,-63], PARAMETER[&quot;scale_factor&quot;,0.9996], PARAMETER[&quot;false_easting&quot;,500000], PARAMETER[&quot;false_northing&quot;,0], UNIT[&quot;metre&quot;,1, AUTHORITY[&quot;EPSG&quot;,&quot;9001&quot;]], AXIS[&quot;Easting&quot;,EAST], AXIS[&quot;Northing&quot;,NORTH], AUTHORITY[&quot;EPSG&quot;,&quot;32620&quot;]] 1.2.2 Modifier la projection d’un objet La fonction st_transform() permet de reprojeter un objet sf. plot(st_geometry(mtq)) title(&quot;WGS 84 / UTM zone 20N&quot;) mtq_reproj &lt;- st_transform(mtq, 2154) plot(st_geometry(mtq_reproj)) title(&quot;RGF93 / Lambert-93&quot;) Le site Spatial Reference met à disposition les références de très nombreux systèmes de projection. 1.3 Opérations de géotraitement 1.3.1 Sélection par attributs Les objets sf sont des data.frame, on peut donc sélectionner leur lignes et leur colonnes de la même manière que les data.frame. # selection de ligne mtq[1:2, ] Simple feature collection with 2 features and 9 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 697602 ymin: 1598818 xmax: 710462 ymax: 1640653 CRS: 32620 INSEE_COM STATUS LIBGEO POP MED CHOM ACT NOM 1 97201 Simple municipality L&#39;Ajoupa-Bouillon 1902 13633 254 801 L&#39; Ajoupa-Bouillon 2 97202 Simple municipality Les Anses-d&#39;Arlet 3737 14558 425 1659 Les Anses-d&#39;Arlet Population.totale geometry 1 1964 MULTIPOLYGON (((699261 1637... 2 3686 MULTIPOLYGON (((709840 1599... mtq[mtq$LIBGEO==&quot;Fort-de-France&quot;, ] Simple feature collection with 1 feature and 9 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 704269 ymin: 1614308 xmax: 711651 ymax: 1626937 CRS: 32620 INSEE_COM STATUS LIBGEO POP MED CHOM ACT NOM 9 97209 Prefecture Fort-de-France 82502 16927 10046 37615 Fort-de-France Population.totale geometry 9 82030 MULTIPOLYGON (((706345 1626... # selection de colonnes mtq[mtq$LIBGEO==&quot;Fort-de-France&quot;, 1:4] Simple feature collection with 1 feature and 4 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 704269 ymin: 1614308 xmax: 711651 ymax: 1626937 CRS: 32620 INSEE_COM STATUS LIBGEO POP geometry 9 97209 Prefecture Fort-de-France 82502 MULTIPOLYGON (((706345 1626... 1.3.2 Sélection spatiale Sélection des communes intesectant Fort-de-France fdf &lt;- mtq[mtq$LIBGEO == &quot;Fort-de-France&quot;, ] mtq$fdf &lt;- st_intersects(x = mtq, y = fdf, sparse = FALSE) plot(st_geometry(mtq)) plot(st_geometry(mtq[mtq$fdf,]), col = &quot;grey&quot;, add = TRUE) 1.3.3 Extraire des centroides mtq_c &lt;- st_centroid(mtq) plot(st_geometry(mtq)) plot(st_geometry(mtq_c), add=TRUE, cex=1.2, col=&quot;red&quot;, pch=20) 1.3.4 Créer une matrice de distances Si le système de projection du jeu de données est renseigné les distances sont exprimées dans l’unité de mesure de la projection (en mètres le plus souvent). mat &lt;- st_distance(x = mtq_c, y = mtq_c) mat[1:5,1:5] Units: [m] [,1] [,2] [,3] [,4] [,5] [1,] 0.000 35316.29 3019.561 12247.132 17181.321 [2,] 35316.293 0.00 38303.361 25478.399 18597.357 [3,] 3019.561 38303.36 0.000 15099.121 20200.611 [4,] 12247.132 25478.40 15099.121 0.000 7149.189 [5,] 17181.321 18597.36 20200.611 7149.189 0.000 1.3.5 Agréger des polygones mtq_u &lt;- st_union(mtq) plot(st_geometry(mtq), col=&quot;lightblue&quot;) plot(st_geometry(mtq_u), add=T, lwd=2, border = &quot;red&quot;) 1.3.6 Agréger des polygones en fonction d’une variable mtq_u2 &lt;- aggregate(x = mtq[,c(&quot;POP&quot;, &quot;CHOM&quot;, &quot;ACT&quot;)], by = list(STATUS = mtq$STATUS), FUN = &quot;sum&quot;) plot(mtq_u2[&quot;STATUS&quot;], key.pos = NULL) 1.3.7 Construire une zone tampon mtq_b &lt;- st_buffer(x = mtq_u, dist = 2000) plot(st_geometry(mtq), col=&quot;lightblue&quot;) plot(st_geometry(mtq_u), add=T, lwd=2) plot(st_geometry(mtq_b), add=T, lwd=2, border = &quot;red&quot;) 1.3.8 Réaliser une intersection m &lt;- rbind(c(700015,1624212), c(700015,1641586), c(719127,1641586), c(719127,1624212), c(700015,1624212)) p &lt;- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq)) plot(st_geometry(mtq)) plot(p, border=&quot;red&quot;, lwd=2, add=T) mtq_z &lt;- st_intersection(x = mtq, y = p) plot(st_geometry(mtq)) plot(st_geometry(mtq_z), col=&quot;red&quot;, border=&quot;green&quot;, add=T) plot(st_geometry(mtq_z)) 1.3.9 Compter des points dans un polygone pts &lt;- st_sample(x = mtq, size = 50) plot(st_geometry(mtq)) plot(pts, pch = 20, col = &quot;red&quot;, add=TRUE, cex = 1) inter &lt;- st_intersects(mtq, pts) mtq$nbpts &lt;- sapply(X = inter, FUN = length) plot(st_geometry(mtq)) plot(st_geometry(mtq[mtq$nbpts&gt;2,]), col = &quot;grey&quot;, add=TRUE) plot(pts, pch = 20, col = &quot;red&quot;, add=TRUE, cex = 1) 1.3.10 Construire des polygones de Voronoi google: “st_voronoi R sf” (https://github.com/r-spatial/sf/issues/474 &amp; https://stackoverflow.com/questions/45719790/create-voronoi-polygon-with-simple-feature-in-r) mtq_v &lt;- st_voronoi(x = st_union(mtq_c)) mtq_v &lt;- st_intersection(st_cast(mtq_v), st_union(mtq)) mtq_v &lt;- st_join(x = st_sf(mtq_v), y = mtq_c, join=st_intersects) mtq_v &lt;- st_cast(mtq_v, &quot;MULTIPOLYGON&quot;) plot(st_geometry(mtq_v), col=&#39;lightblue&#39;) 1.3.11 Construction d’objets sf 1.3.11.1 POINTS library(sf) pt1_sfg &lt;- st_point(c(1,2)) pt2_sfg &lt;- st_point(c(3,4)) pt3_sfg &lt;- st_point(c(2,1)) (pt_sfc &lt;- st_sfc(pt1_sfg,pt2_sfg,pt3_sfg, crs = (4326))) Geometry set for 3 features geometry type: POINT dimension: XY bbox: xmin: 1 ymin: 1 xmax: 3 ymax: 4 CRS: EPSG:4326 pt_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (pt_sf &lt;- st_sf(pt_df,geometry = pt_sfc)) Simple feature collection with 3 features and 4 fields geometry type: POINT dimension: XY bbox: xmin: 1 ymin: 1 xmax: 3 ymax: 4 CRS: EPSG:4326 id cat var1 var2 geometry 1 1 A 10 2.3 POINT (1 2) 2 2 B 20 1.9 POINT (3 4) 3 3 A 30 4.0 POINT (2 1) plot(pt_sf) 1.3.11.2 POLYGON p1 &lt;- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)) p2 &lt;- rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0)) p3 &lt;- rbind(c(3,3), c(4,2), c(4,3), c(3,3)) pol1_sfg &lt;-st_polygon(list(p1)) pol2_sfg &lt;-st_polygon(list(p2)) pol3_sfg &lt;-st_polygon(list(p3)) (pol_sfc &lt;- st_sfc(pol1_sfg, pol2_sfg, pol3_sfg, crs = 4326)) Geometry set for 3 features geometry type: POLYGON dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 CRS: EPSG:4326 pol_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (pol_sf &lt;- st_sf(pol_df,geometry = pol_sfc)) Simple feature collection with 3 features and 4 fields geometry type: POLYGON dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 CRS: EPSG:4326 id cat var1 var2 geometry 1 1 A 10 2.3 POLYGON ((0 0, 1 0, 3 2, 2 ... 2 2 B 20 1.9 POLYGON ((3 0, 4 0, 4 1, 3 ... 3 3 A 30 4.0 POLYGON ((3 3, 4 2, 4 3, 3 3)) plot(pol_sf) 1.3.11.3 LINESTRING p1 &lt;- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4)) p2 &lt;- rbind(c(3,0), c(4,0), c(4,1), c(3,1)) p3 &lt;- rbind(c(3,3), c(4,2), c(4,3)) ls1_sfg &lt;-st_linestring(p1) ls2_sfg &lt;-st_linestring(p2) ls3_sfg &lt;-st_linestring(p3) (ls_sfc &lt;- st_sfc(ls1_sfg, ls2_sfg, ls3_sfg, crs = 4326)) Geometry set for 3 features geometry type: LINESTRING dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 CRS: EPSG:4326 ls_df &lt;- data.frame(id= c(1,2,3), cat = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;), var1 = c(10,20,30), var2 = c(2.3,1.9,4)) (ls_sf &lt;- st_sf(ls_df,geometry = ls_sfc)) Simple feature collection with 3 features and 4 fields geometry type: LINESTRING dimension: XY bbox: xmin: 0 ymin: 0 xmax: 4 ymax: 4 CRS: EPSG:4326 id cat var1 var2 geometry 1 1 A 10 2.3 LINESTRING (0 0, 1 0, 3 2, ... 2 2 B 20 1.9 LINESTRING (3 0, 4 0, 4 1, ... 3 3 A 30 4.0 LINESTRING (3 3, 4 2, 4 3) plot(ls_sf) 1.4 Géocodage d’adresses Plusieurs packages permettent de géocoder des adresses. photon (Giraud 2017b), utilise l’API de photon qui exploite les données d’OpenStreetMap. Ce package n’est pas sur le CRAN. Pour l’installer : library(remotes) install_github(repo = &#39;rCarto/photon&#39;) library(photon) address &lt;- c(&quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;, &quot;8 place Paul Ricoeur, 75013 Paris&quot;) place &lt;- photon::geocode(address, limit = 1, key = &quot;place&quot;, lang = &quot;fr&quot;) place location osm_id osm_type name housenumber 1 19 rue Michel Bakounine, 29600 Morlaix, France 3241060871 N &lt;NA&gt; 19 2 8 place Paul Ricoeur, 75013 Paris 2608793979 N &lt;NA&gt; 8 street postcode city state country osm_key osm_value lon 1 Rue Michel Bakounine 29600 Morlaix Bretagne France place house -3.816435 2 Place Paul Ricoeur 75013 Paris Île-de-France France place house 2.382483 lat msg 1 48.59041 &lt;NA&gt; 2 48.82670 &lt;NA&gt; nominatim (Rudis 2019), utilise l’API de nominatim qui exploite les données d’OpenStreetMap. Ce package n’est pas sur le CRAN. Une clef d’API est nécessaire pour l’utiliser (obtenir une clef chez Maquest). Pour l’installer : library(remotes) install_github(repo = &#39;hrbrmstr/nominatim&#39;) library(nominatim) address &lt;- c(URLencode(&quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;), URLencode(&quot;8 place Paul Ricoeur, 75013 Paris&quot;)) place &lt;- osm_geocode(address, country_codes = &quot;FR&quot;, key = &quot;UneClefMapQuestValide&quot;) place place_id 1 44644129 2 27209988 licence 1 Data © OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright 2 Data © OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright osm_type osm_id lat lon 1 node 3241060871 48.59041 -3.816435 2 node 2608793979 48.82670 2.382483 display_name 1 19, Rue Michel Bakounine, Ploujean, Kerozar, Morlaix, Finistère, Brittany, Metropolitan France, 29600, France 2 8, Place Paul Ricoeur, Gare, 13th Arrondissement, Paris, Ile-de-France, Metropolitan France, 75013, France class type importance bbox_left bbox_top bbox_right bbox_bottom 1 place house 0.741 48.59036 48.59046 -3.816485 -3.816384 2 place house 0.631 48.82665 48.82675 2.382433 2.382533 banR (Gombin and Chevalier 2017), pour des adresses en France uniquement. library(banR) address &lt;- c(&quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;, &quot;8 place Paul Ricoeur, 75013 Paris&quot;) place &lt;- geocode_tbl(tbl = data.frame(address), adresse = &quot;address&quot;) place address latitude longitude 1 19 rue Michel Bakounine, 29600 Morlaix, France 48.59042 -3.816429 2 8 place Paul Ricoeur, 75013 Paris 48.82673 2.382450 result_label result_score result_type result_id 1 19 Rue Michel Bakounine 29600 Morlaix 0.78 housenumber ADRNIVX_0000000266085152 2 8 Place Paul Ricoeur 75013 Paris 0.93 housenumber ADRNIVX_0000000331930326 result_housenumber result_name result_street result_postcode result_city 1 19 Rue Michel Bakounine &lt;NA&gt; 29600 Morlaix 2 8 Place Paul Ricoeur &lt;NA&gt; 75013 Paris result_context result_citycode 1 29, Finistère, Bretagne 29151 2 75, Paris, Île-de-France 75113 Transformer les données en objet sf library(sf) library(cartography) place_sf &lt;- st_as_sf(place, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) osm_fr &lt;- getTiles(x = place_sf, zoom = 7 ) tilesLayer(osm_fr) plot(st_geometry(place_sf), pch = 20, cex = 4, col = &quot;red&quot;, add=T) 1.5 Importer des données OSM OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le Monde entier. Le package osmdata (Padgham et al. 2017) permet d’extraire des données vectorielles depuis OSM. Site web du package osmdata library(sf) library(osmdata) library(sf) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) # Définition d&#39;une bounding box q &lt;- opq(bbox=st_bbox(st_transform(mtq,4326))) # Extraction des restaurants res &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;restaurant&quot;) res.sf &lt;- osmdata_sf(res) res.sf.pts &lt;- res.sf$osm_points[!is.na(res.sf$osm_points$amenity),] resto &lt;- st_transform(res.sf.pts, st_crs(mtq)) # Affichage des restaurants plot(st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, bg = &quot;lightblue1&quot;) plot(st_geometry(resto), add=TRUE, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) title(&quot;Répartition des restaurants&quot;) mtext(text = &quot;INSEE, 2016 - OSM, 2019&quot;,side = 1, line = -1, cex = 0.8) 1.6 Exercices Exercices de traitement de données spatiales References "],
["chapitre2.html", "Chapitre 2 Cartographie thématique 2.1 Le package cartography 2.2 Représentations usuelles 2.3 Combinaisons de représentations 2.4 Mise en page 2.5 Exercices", " Chapitre 2 Cartographie thématique Nous ne détaillerons pas ici les règles de la cartographie thématique. Le lecteur pourra se référer à divers ouvrages de référence : Bertin (1967), Pumain and Béguin (2010), Lambert and Zanin (2016). Plusieurs packages peuvent être utilisés pour réaliser des cartes thématique. Le package ggplot2 (Wickham 2016) par exemple permet d’afficher des objets spatiaux et de réaliser des cartes thématiques simples. Le package tmap (Tennekes 2018) est dédié à la création de cartes thématiques, il utilise une syntaxe proche de celle de ggplot2 (enchaînement d’instructions combinées avec le signe ‘+’). La documentation et les tutoriels pour utiliser ces deux packages sont facilement accessibles sur le web. Dans ce chapitre nous utiliserons principalement le package cartography (Giraud and Lambert 2018a) dont les fonctionnalités sont assez complètes et qui est mieux maitrisé pas les auteurs du manuel. 2.1 Le package cartography Le package cartography permet de créer et d’intégrer des cartes thématiques dans sa chaîne de traitements avec R. Il permet des représentations cartographiques telles que les cartes de symboles proportionnels, des cartes choroplèthes, des typologies, des cartes de flux ou des cartes de discontinuités. Il offre également des fonctions qui permettent d’améliorer la réalisation de la carte, comme des palettes de couleur, des éléments d’habillage (échelle, flèche du nord, titre, légende…), d’y rattacher des labels ou d’accéder à des APIs cartographiques. Pour utiliser ce package plusieurs sources peuvent être consultées : La documentation du package accessible sur internet ou directement dans R (?cartography), La vignette associée au package présente des exemples de scripts, Le blog R Géomatique qui met à disposition ressources et exemples liés au package et plus généralement à l’écosystème spatiale de R, La cheat sheet de cartography, qui résume les principales fonctions du package de façon synthétique. Les fonctions de cartography dédiées à la représentation utilisent le suffixe Layer. En général l’argument x est utilisé par un objet sf et l’argument var sert à renseigner la variable à représenter. 2.2 Représentations usuelles 2.2.1 Carte de symboles proportionnels Les cartes de symboles proportionnels sont utilisées pour représenter les variables de stocks (variables quantitatives absolues, la somme et la moyenne ont un sens). La fonction propSymbolsLayer() propose cette représentation, plusieurs symboles sont disponibles : cercles, carrés et barres. library(cartography) library(sf) # Import des données mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) # Communes plot( st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot; ) # Symboles proportionnels propSymbolsLayer( x = mtq, var = &quot;POP&quot;, legend.title.txt = &quot;Population totale\\n(2015)&quot; ) # Titre title(main = &quot;Population en Martinique&quot;) 2.2.2 Carte choroplèthe Les cartes choroplèthes sont utilisées pour représenter les variables de ratios (variables quantitatives relatives, la moyenne a un sens, la somme n’a pas de sens). Pour ce genre de représentation il faut au préalable : choisir une méthode de discrétisation pour transformer une série statistique continue en classes définies par des intervalles, choisir un nombre de classes, choisir une palette de couleurs. La fonction choroLayer() permet de créer des cartes choroplètes . Les arguments nclass, method et breaks servent à paramétrer les discrétisations et la fonction getBreaks() permet de travailler sur les discrétisations en dehors de la fonction choroLayer(). De même, l’argument col est utilisé pour renseigner une palette de couleur mais plusieurs fonctions peuvent être utilisées pour paramétrer les palettes en dehors de la fonction (carto.pal()…). # Densité de population (hab./km2) en utilisant la fonction sf::st_area() mtq$POPDENS &lt;- 1e6 * mtq$POP / as.numeric(st_area(mtq)) choroLayer( x = mtq, var = &quot;POPDENS&quot;, breaks = c(33, 75, 168, 377, 845, 1895), col = c(&quot;#F1B1B4&quot;, &quot;#E3898E&quot;, &quot;#D35E63&quot;, &quot;#BD2D33&quot;, &quot;#7E1512&quot;), legend.title.txt = &quot;Densité de population\\n(habitants par km2)&quot; ) title(main = &quot;Distribution de la population en Martinique (2015)&quot;) 2.2.2.1 Discrétisations La fonction getBreaks() met à disposition les méthodes de discrétisations de variables classique : quantiles, moyenn/écart-type, amplitudes égales, moyennes emboitées, Fisher-Jenks, géométrique … var &lt;- mtq$POPDENS moy &lt;- mean(var) med &lt;- median(var) std &lt;- sd(var) breaks &lt;- getBreaks(v = var, nclass = 5, method = &quot;quantile&quot;) hist(var, probability = TRUE, breaks = breaks, main=&quot;quantiles&quot;, col = carto.pal(pal1 = &quot;wine.pal&quot;,3, &quot;green.pal&quot;, 3)) rug(var) abline(v = med, col = &quot;blue&quot;, lwd = 3) breaks &lt;- getBreaks(v = var, nclass=5, method = &quot;geom&quot;) hist(var, probability = TRUE, breaks = breaks, main=&quot;progression géométrique&quot;, col = carto.pal(pal1 = &quot;wine.pal&quot;,6)) rug(var) 2.2.2.2 Palettes de couleurs La fonction display.carto.all() permet d’afficher toutes palettes de couleurs disponibles dans cartography. display.carto.all(20) La fonction display.carto.pal() permet de détailler une palette de couleurs. display.carto.pal(&quot;turquoise.pal&quot;) La fonction carto.pal() permet de construire une palette de couleur. Il est possible de créer des palettes associant 2 couleurs. mypal &lt;- carto.pal(pal1 = &quot;wine.pal&quot;, n1 = 5, pal2 = &quot;green.pal&quot;, n2 = 4) image(1:9, 1, as.matrix(1:9), col=mypal, xlab = &quot;&quot;, ylab = &quot;&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;,bty = &quot;n&quot;) 2.2.3 Carte de typologie Les cartes de typologies sont utilisées pour représenter les variables qualitatives. La fonction typoLayer() propose cette représentation. L’argument legend.values.order sert à ordonner les modalités dans la légende. typoLayer( x = mtq, var=&quot;STATUS&quot;, col = c(&quot;aquamarine4&quot;, &quot;yellow3&quot;,&quot;wheat&quot;), lwd = .7, legend.values.order = c(&quot;Prefecture&quot;, &quot;Sub-prefecture&quot;, &quot;Simple municipality&quot;), legend.pos = &quot;topright&quot;, legend.title.txt = &quot;&quot; ) title(&quot;Statut Administratif&quot;) 2.3 Combinaisons de représentations Plusieurs fonctions sont dédiées à la représentation combinée de 2 variables. 2.3.1 Carte de stocks et de ratios La fonction propSymbolsChoroLayer() représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur repose sur la discrétisation d’une seconde variable. La fonction utilise les arguments des fonctions propSymbolsLayer() et choroLayer(). plot( st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, bg = &quot;lightblue1&quot; ) propSymbolsChoroLayer( x = mtq, var = &quot;POP&quot;, border = &quot;grey50&quot;, lwd = 1, legend.var.pos = &quot;topright&quot;, legend.var.title.txt = &quot;Population&quot;, var2 = &quot;MED&quot;, method = &quot;equal&quot;, nclass = 4, col = carto.pal(pal1 = &quot;sand.pal&quot;, n1 = 4), legend.var2.values.rnd = -2, legend.var2.pos = &quot;left&quot;, legend.var2.title.txt = &quot;Revenu\\nmédian\\n(en euros)&quot; ) title(&quot;Population et richesse en Martinique, 2015&quot;) 2.3.2 Carte de stocks et de qualitative La fonction propSymbolsTypoLayer() représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur représente les modalités d’une variable qualitative. La fonction utilise les arguments des fonctions propSymbolsLayer() et typoLayer(). plot( st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, bg = &quot;lightblue1&quot; ) propSymbolsTypoLayer( x = mtq, var = &quot;POP&quot;, symbols = &quot;circle&quot;, var2 = &quot;STATUS&quot;, col = c(&quot;aquamarine4&quot;, &quot;yellow3&quot;,&quot;wheat&quot;), legend.var.pos = &quot;bottomleft&quot;, legend.var.title.txt = &quot;Population\\n(2015)&quot;, legend.var2.title.txt = &quot;Statut administratif&quot;, legend.var2.values.order = c(&quot;Prefecture&quot;, &quot;Sub-prefecture&quot;, &quot;Simple municipality&quot;) ) title(&quot;Population en Martinique&quot;) 2.4 Mise en page Pour être finalisée, une carte thématique doit contenir certains éléments aditionnels tels que : le titre, l’auteur, la source, l’échelle, l’orientation… 2.4.1 Habillage complet La fonction layoutLayer() permet d’afficher tous ces éléments. plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) layoutLayer( title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, north = TRUE ) Plusieurs arguments permettent de paramétrer plus finement les éléments d’habillage pour aboutir à des cartes plus personnalisées (tabtitle, col, coltitle, theme…). plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) layoutLayer( title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, north = TRUE, scale = 5, frame = FALSE, tabtitle = TRUE, theme = &quot;turquoise.pal&quot; ) 2.4.2 Flèche d’orientation La fonction north() permet de mieux choisir la position et l’aspect de la flèche d’orientation. plot(st_geometry(mtq), col = &quot;#D1914D&quot;, border = &quot;white&quot;) north(pos = &quot;topleft&quot;, col = &quot;#D1914D&quot;) layoutLayer(title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, frame = FALSE, scale = 5, coltitle = &quot;#D1914D&quot;,tabtitle = TRUE, postitle = &quot;right&quot;) Par défaut, la flèche d’orientation pointe vers le haut de la figure. Il est possible, avec l’argument x, d’utiliser une couche de référence pour indiquer le nord géographique. mtq_proj &lt;- st_transform(mtq, 2154) plot(st_geometry(mtq_proj), col = &quot;#D1914D&quot;, border = &quot;white&quot;) north(pos = &quot;topright&quot;, col = &quot;#D1914D&quot;, x = mtq_proj) layoutLayer(title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, frame = FALSE, scale = 5, coltitle = &quot;#D1914D&quot;,tabtitle = TRUE, postitle = &quot;left&quot;) 2.4.3 Échelle La fonction barscale() permet de mieux choisir la position et l’aspect de l’échelle. plot(st_geometry(mtq), col = &quot;#D1914D&quot;, border = &quot;white&quot;) barscale( size = 5, lwd = 2, cex = 1.2, pos = c(713712.6,1594777) ) layoutLayer(title = &quot;Martinique&quot;, sources = &quot;IGN&quot;, author = &quot;Giraud &amp; Pécout, 2019&quot;, scale = NULL, coltitle = &quot;#D1914D&quot;,tabtitle = TRUE) 2.4.4 Étiquettes La fonction labelLayer() est dédiée à l’afichage d’étiquettes. plot(st_geometry(mtq), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, bg = &quot;#A6CAE0&quot;) labelLayer( x = mtq, txt = &quot;LIBGEO&quot;, col= &quot;black&quot;, cex = 0.7, font = 4, halo = TRUE, bg = &quot;white&quot;, r = 0.1, overlap = FALSE, show.lines = FALSE ) layoutLayer(title = &quot;Communes&quot;, tabtitle = TRUE, author = &quot;INSEE, 2016&quot;, sources =&quot;&quot;, north =TRUE, frame = FALSE, scale = 5) L’argument halo = TRUE permet d’afficher un leger halo autour des étiquettes et l’argument overlap = FALSE permet de créer des étiquettes ne se recouvrant pas. 2.4.5 Ajuster les marges d’une figure Pour modifier les marges d’une figure (carte ou autre) il faut utiliser la fonction par() qui défini certains paramètres graphiques des figures et son argument mar. La fonction dev.off() efface tous les graphiques en mémoire et permet de réinitialiser les valeurs par défaut. # Modification de la couleur de fond des graphique par(bg=&quot;grey90&quot;) plot(st_geometry(mtq), main=&quot;Marges par défaut&quot;) # Modification des marges par(mar=c(0,0,1.2,0)) plot(st_geometry(mtq), main=&quot;Marges paramétrées&quot;) 2.4.6 Centrer la carte sur une région Plusieurs solutions sont possible : La fonction ghostLayer() permet de centrer une carte sur un objet sf particulier. carbet &lt;- mtq[mtq$LIBGEO==&quot;Le Carbet&quot;,] # centrage sur la couche cible &quot;invisible&quot; ghostLayer( x = carbet, bg = &quot;#A6CAE0&quot; ) # affichage des communes plot( st_geometry(mtq), col = &quot;darkseagreen1&quot;, border = &quot;darkseagreen4&quot;, add=TRUE ) # affichage de la couche d&#39;intérêt plot( st_geometry(carbet), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, lwd = 2, add=TRUE ) layoutLayer( title = &quot;Le Carbet&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = 1, tabtitle = TRUE, frame=FALSE ) Afficher une couche de la zone de zoom sans couleur pour le fond et les bordures puis afficher les couches que l’on souhaite afficher. carbet &lt;- mtq[mtq$LIBGEO==&quot;Le Carbet&quot;,] # affichage de la couche de zoom &quot;invisible&quot; plot( st_geometry(carbet), col = NA, border = NA, bg = &quot;#A6CAE0&quot; ) # affichage des communes plot( st_geometry(mtq), col = &quot;darkseagreen1&quot;, border = &quot;darkseagreen4&quot;, add=TRUE ) # affichage de la couche d&#39;intérêt plot( st_geometry(carbet), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, lwd = 2, add=TRUE ) layoutLayer( title = &quot;Le Carbet&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = 1, tabtitle = TRUE, frame=FALSE ) Utiliser les paramètres xlim et ylim de la fonction plot() aves les valeurs fournies par la fonction st_bbox() diams &lt;- mtq[mtq$LIBGEO==&quot;Le Diamant&quot;,] diams_bb &lt;- st_bbox(diams) # affichage des communes plot( st_geometry(mtq), col = &quot;darkseagreen1&quot;, border = &quot;darkseagreen4&quot;, xlim = diams_bb[c(1,3)], ylim = diams_bb[c(2,4)], bg = &quot;#A6CAE0&quot; ) # affichage de la couche d&#39;intérêt plot( st_geometry(diams), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, lwd = 2, add=TRUE ) layoutLayer( title = &quot;Le Diamant&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = 1, tabtitle = TRUE, frame=FALSE ) 2.4.7 Afficher plusieurs cartes sur la même figure Il faut ici utiliser l’argument mfrow de la fonction par(). Le premier chiffre représente le nombre lignes et le deuxième le nombre de colonnes. # deux lignes et deux colonnes par(mfrow=c(2,2)) plot(st_geometry(mtq), col=&quot;red&quot;) plot(st_geometry(mtq), col=&quot;blue&quot;) plot(st_geometry(mtq), col=&quot;green&quot;) plot(st_geometry(mtq), col=&quot;yellow&quot;) # une ligne et deux colonnes par(mfrow=c(1,2), mar = c(0,.2,1.2,.2)) # 1ere carte carbet_bb &lt;- st_bbox(carbet) plot(st_geometry(mtq), col = &quot;darkseagreen1&quot;, border = &quot;darkseagreen4&quot;, xlim = carbet_bb[c(1,3)], ylim = carbet_bb[c(2,4)], bg = &quot;#A6CAE0&quot;) plot(st_geometry(carbet), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, lwd = 2, add=TRUE) layoutLayer(title = &quot;Le Carbet&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = 1, tabtitle = TRUE, frame=FALSE) # 2eme carte plot(st_geometry(mtq), col = &quot;darkseagreen1&quot;, border = &quot;darkseagreen4&quot;, xlim = diams_bb[c(1,3)], ylim = diams_bb[c(2,4)], bg = &quot;#A6CAE0&quot;) plot(st_geometry(diams), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, lwd = 2, add=TRUE) layoutLayer(title = &quot;Le Diamant&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = 1, tabtitle = TRUE, frame=FALSE) # une ligne et deux colonnes par(mfrow=c(2,1), mar = c(0.2,0,1.4,0)) # 1ere carte carbet_bb &lt;- st_bbox(carbet) plot(st_geometry(mtq), col = &quot;darkseagreen1&quot;, border = &quot;darkseagreen4&quot;, xlim = carbet_bb[c(1,3)], ylim = carbet_bb[c(2,4)], bg = &quot;#A6CAE0&quot;) plot(st_geometry(carbet), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, lwd = 2, add=TRUE) layoutLayer(title = &quot;Le Carbet&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = 1, tabtitle = TRUE, frame=FALSE) # 2eme carte plot(st_geometry(mtq), col = &quot;darkseagreen1&quot;, border = &quot;darkseagreen4&quot;, xlim = diams_bb[c(1,3)], ylim = diams_bb[c(2,4)], bg = &quot;#A6CAE0&quot;) plot(st_geometry(diams), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, lwd = 2, add=TRUE) layoutLayer(title = &quot;Le Diamant&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = 1, tabtitle = TRUE, frame=FALSE) 2.4.8 Obtenir un ratio de figure adapté Il est assez difficile d’exporter des figures (cartes ou autres) dont le ratio hauteur/largeur soit satisfaisant. Le ratio par défaut des figure au format png est de 1 (480x480 pixels) : png(filename = &quot;img/martinique1.png&quot;, res = 96) par(mar = c(0,0,1.2,0), bg = &quot;grey90&quot;) plot(st_geometry(mtq), bg = &quot;#A6CAE0&quot;, col = &quot;#D1914D&quot;, border = &quot;white&quot;) layoutLayer(title = &quot;Martinique&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = NULL) dev.off() Sur cette carte beaucoup d’espace est perdu à l’est et à l’ouest de l’ile. La fonction getFigDim() de cartography permet de choisir un ratio hauteur/largeur correspondant à l’emprise d’un objet sf en prenant en compte une largeur (ou hauteur) fixée, les paramètres de marges et la résolution souhaitée. getFigDim(x = mtq, width = 480, mar = c(0,0,1.2,0), res = 96) [1] 480 585 png(filename = &quot;img/martinique2.png&quot;, width = 480, height = 583, res = 96) par(mar = c(0,0,1.2,0), bg = &quot;grey90&quot;) plot(st_geometry(mtq), bg = &quot;#A6CAE0&quot;, col = &quot;#D1914D&quot;, border = &quot;white&quot;) layoutLayer(title = &quot;Martinique&quot;, sources = &quot;&quot;, author = &quot;&quot;, scale = NULL) dev.off() L’emprise de cette carte est exactement celle de l’île. 2.4.9 Ajouter une image sur une carte Cela peut être utile pour ajouter un logo, un pictogramme. La fonction readPNG() du package png permet l’ajout d’images sur une figure. library(png) # import de l&#39;image logo &lt;- readPNG(&quot;img/mapmonster.png&quot;) # dimension de l&#39;image en unité de la carte pp &lt;- dim(logo)[2:1] * 16 # Définition d&#39;un point d&#39;encrage de l&#39;image dans la figure, ici # le coin inférieur gauche de la bounding box de la martique. xy &lt;- st_bbox(mtq)[1:2] par(mar = c(0,0,1.2,0)) plot(st_geometry(mtq), bg = &quot;#A6CAE0&quot;, col = &quot;#D1914D&quot;, border = &quot;white&quot;) rasterImage( image = logo, xleft = xy[1], ybottom = xy[2], xright = xy[1] + pp[1], ytop = xy[2] + pp[2] ) layoutLayer(title = &quot;Martinique&quot;, tabtitle = TRUE, frame = FALSE, sources = &quot;&quot;, author = &quot;&quot;, scale = NULL) 2.4.10 Placer précisément un élément sur la carte La fonction locator() permet de cliquer sur une figure et d’obtenir les coordonnées d’un point dans le système de coordonnées de la figure (de la carte). plot(st_geometry(mtq), col = &quot;darkseagreen3&quot;, border = &quot;darkseagreen4&quot;, bg = &quot;#A6CAE0&quot;) text(x = 694019, y = 1615161, labels = &quot;MER\\nDES\\nCARAÏBES&quot;, col = &quot;#e3f1f9&quot;, font = 3, srt=20) locator()peut être utilisée sur la plupart des graphiques (pas ceux produits avec ggplot2). How to interactively position legends and layout elements on a map with cartography 2.4.11 Utiliser un fond de carte OSM La fonction getTiles() permet de télécharger des fonds de cartes OSM et la fonction tilesLayer() permet de les afficher. osm_tiles &lt;- getTiles(x = mtq, zoom = 10, crop = TRUE) par(mar = c(0,0,0,0)) tilesLayer(osm_tiles) mtext( side = 1, line = -1, cex = .7, text = &quot;© OpenStreetMap contributors.\\n Tiles style under CC BY-SA, www.openstreetmap.org/copyright.&quot;, col=&quot;red&quot; ) 2.4.12 Créer un effet crayonné library(sf) mtq_pencil &lt;- getPencilLayer(x = mtq) typoLayer( x = mtq_pencil, var=&quot;STATUS&quot;, col = c(&quot;aquamarine4&quot;, &quot;yellow3&quot;,&quot;wheat&quot;), lwd = .7, legend.values.order = c(&quot;Prefecture&quot;, &quot;Sub-prefecture&quot;, &quot;Simple municipality&quot;), legend.pos = &quot;topright&quot;, legend.title.txt = &quot;&quot; ) plot(st_geometry(mtq), add = TRUE, ldy=2) layoutLayer(title = &quot;Statut Administratif&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) Colored Pencil Maps with R 2.4.13 Ajouter un ombrage à une couche plot(st_geometry(mtq) + c(500, -500), col = &quot;grey50&quot;, border = NA, bg = &quot;lightblue1&quot;) plot(st_geometry(mtq), col=&quot;darkseagreen3&quot;, border=&quot;darkseagreen4&quot;, add=TRUE) layoutLayer(title = &quot;Communes&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, north=TRUE, frame=FALSE, scale = 5) 2.4.14 Création de cartons Le package mapinsetr(Giraud and Lambert 2018b) est dédié à la crétion de cartons cartographiques. Il n’est pas sur le CRAN pour l’instant, mais on peut l’installer via le package remotes. remotes::install_github(&quot;riatelab/mapinsetr&quot;) mapinsetr permet de découper, redimensionner et déplacer une zone d’un fond de carte. library(mapinsetr) library(cartography) library(sf) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) resto &lt;- st_read(&quot;data/resto.gpkg&quot;, quiet = TRUE) # Création d&#39;un masque box_FDF &lt;- create_mask(bb = c(706880, 1615030, 708650, 1616870), prj = st_crs(mtq)) # Découpage, déplacement et redimentionnement des couches sous le masque zbox_FDF &lt;- move_and_resize( x = box_FDF, mask = box_FDF, xy = c(689000, 1603000), k = 7 ) zmtq_FDF &lt;- move_and_resize( x = mtq, mask = box_FDF, xy = c(689000, 1603000), k = 7 ) zresto_FDF &lt;- move_and_resize( x = resto, mask = box_FDF, xy = c(689000, 1603000), k = 7 ) # Affichage de la carte et des couhes crées plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) plot(st_geometry(resto), add=T, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) plot(st_geometry(box_FDF), border = &quot;red&quot;, add = T, lwd = 2) plot(st_geometry(zmtq_FDF), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, add=TRUE) plot(st_geometry(zresto_FDF), add=TRUE, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) plot(st_geometry(zbox_FDF), border = &quot;red&quot;, add = T, lwd = 2) layoutLayer(title = &quot;Carte initiale + couches créées&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, north=TRUE, frame=FALSE, scale = 5) # Création de couches unqiues comprenant le zoom resto &lt;- inset_rbinder(l = list(resto, zresto_FDF)) mtq &lt;- inset_rbinder(l = list(mtq, zmtq_FDF)) box &lt;- inset_rbinder(l = list(box_FDF, zbox_FDF)) plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) plot(st_geometry(resto), add=T, pch=20, col = &quot;#330A5FFF&quot;, cex = 0.5) plot(st_geometry(box), border = &quot;red&quot;, add = T, lwd = 2) layoutLayer(title = &quot;Carte finale avec carton&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016&quot;, sources=&quot;&quot;, north=TRUE, frame=FALSE, scale = 5) 2.5 Exercices Exercices de cartographie thématique References "],
["chapitre3.html", "Chapitre 3 Cartographie thématique avancée 3.1 Les cartes de discontinuités 3.2 Les grilles régulières 3.3 Le lissage spatial 3.4 Cartes en 3D 3.5 Les cartogrammes 3.6 Cartographie interactive", " Chapitre 3 Cartographie thématique avancée 3.1 Les cartes de discontinuités Ce type de représentation permet de souligner cartographiquement les discontinuités territoriales d’un phénomène. L’accent est porté sur ce qui distingue des territoires. Pour chaque frontière nous calculons le rapports ou la différence des valeurs des polygones de part et d’autre. Puis nous représentons la frontière par un figuré d’autant plus épais que la différence est forte. Il est souvent bénéfique de coupler ce type de représentation à une représentation choroplèthe (pour comprendre le sens des discontinuités). Ces cartes ne sont pas évidentes à paramétrer. Le choix des critères (seuil, type de différences…) influence fortement la représentation. En fonction du maillage utilisé la lisibilité de la carte peut être faible. Ces représentations sont très puissantes pour montrer les inégalités. La fonctions getBorder() du package cartography permet de construire une couche des frontières terrestres. La fonction discLayer() permet d’afficher les discontinuités. library(sf) library(cartography) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) # Get borders mtq_bord &lt;- getBorders(x = mtq) # Plot polygons plot(st_geometry(mtq), border = NA, col = &quot;grey60&quot;) # Plot borders plot( st_geometry(mtq_bord), col = sample(x = rainbow(nrow(mtq_bord))), lwd = 3, add = TRUE ) layoutLayer(&quot;Frontières inter-communales&quot;,tabtitle=TRUE, north = TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) # Compute the population density (inhab./km2) using sf::st_area() mtq$POPDENS &lt;- as.numeric(1e6 * mtq$POP / st_area(mtq)) # plot municipalities (only the backgroung color is plotted) plot(st_geometry(mtq), col = NA, border = NA, bg = &quot;lightblue1&quot;, xlim = c(690574, 745940)) # Plot the population density with custom breaks choroLayer(x = mtq, var = &quot;MED&quot;, breaks = c(min(mtq$MED), seq(13000, 21000, 2000), max(mtq$MED)), col = carto.pal(&quot;green.pal&quot;, 6),border = &quot;white&quot;, lwd = 0.5, legend.pos = &quot;topright&quot;, legend.title.txt = &quot;Median Income\\n(euros)&quot;, add = TRUE) # Plot discontinuities discLayer( x = mtq_bord, df = mtq, var = &quot;MED&quot;, type = &quot;rel&quot;, method = &quot;geom&quot;, nclass = 3, threshold = 0.4, sizemin = 0.7, sizemax = 6, col = &quot;red4&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Relative\\nDiscontinuities&quot;, legend.pos = &quot;right&quot;, add = TRUE ) # Layout layoutLayer(title = &quot;Wealth Disparities in Martinique, 2015&quot;, author = paste0(&quot;cartography &quot;, packageVersion(&quot;cartography&quot;)), sources = &quot;Sources: Insee and IGN, 2018&quot;, frame = FALSE, scale = 5, tabtitle = TRUE,theme = &quot;grey.pal&quot;) # north arrow north(pos = &quot;topleft&quot;) 3.2 Les grilles régulières La méthode du carroyage consiste à découper l’espace géographique en un maillage formé de carrés réguliers dans une projection donnée. La donnée est répartie sur ce quadrillage régulier au prorata de la surface représentée. Le quadrillage permet ainsi de s’affranchir des mailles administratives. Ces représentation induisent une perte de précision. Les maillages produit n’ont pas de signification. La version simple (les valeurs sont redistribuées au prorata de la surface), implique une equirépartition du phénomène dans chaque unités. La comparaison de maillages différents, à plusieurs dates ou de différentes sources est rendue possible. La fonction getGridLayer() du package cartography permet de construire ces grilles régulières. library(sf) library(cartography) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) # Plot dentsity of population mtq$dens &lt;- mtq$POP / as.numeric(st_area(mtq) / (1000 * 1000)) bks &lt;- getBreaks(v = mtq$dens, method = &quot;q6&quot;) cols &lt;- carto.pal(pal1 = &quot;taupe.pal&quot;, n1 = 6) choroLayer( x = mtq, var = &quot;dens&quot;, breaks = bks, border = &quot;burlywood3&quot;, col = cols, legend.pos = &quot;topright&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Densité de population\\n(hab/km2)&quot; ) layoutLayer(&quot;Population en Martinique&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) # Création de la grille mygrid &lt;- getGridLayer( x = mtq, cellsize = 10000 * 10000, type = &quot;hexagonal&quot;, var = &quot;POP&quot; ) ## conversion from square meter to square kilometers mygrid$densitykm &lt;- mygrid$POP / (mygrid$gridarea / (1000 * 1000)) choroLayer( x = mygrid, var = &quot;densitykm&quot;, breaks = bks, border = &quot;burlywood3&quot;, col = cols, legend.pos = &quot;topright&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Densité de population\\n(hab/km2)&quot; ) plot(st_geometry(mtq), lwd = 0.2, add=TRUE, border = &quot;#ffffff75&quot;) layoutLayer( title = &quot;Population en Martinique&quot;, tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5 ) north(pos = &quot;topleft&quot;) 3.3 Le lissage spatial L’idée principale du lissage est de filtrer l’information pour révéler des structures spatiales sous-jacentes. C’est un ensemble de méthodes qui consistent à affecter aux points que l’on observe une valeur prenant en compte les valeurs de leur voisinage. Il existe plusieurs méthodes de lissage (kde, potentiels…) plus ou moins paramétrables. Cette méthode permet de passer d’une représentations de données ponctuelles vers la représentation d’une surface continue. Il est difficile de paramétrer correctement les fonctions de lissages. Elles doivent s’appuyer sur des hypothèses de comportement dans l’espace. La compréhension par un public large n’est pas évidente, il faut alors simplifier les légendes, la présentation de la méthode. Permet de faire ressortir des phénomènes spatiaux sous-jacents invisibles directement. Les cartes produites attirent l’oeil par leur originalité. Cette méthode permet de passer d’une représentation ponctuelle ou discontinue (dans un maillage) à une représentation continue s’affranchissant des maillages existants. La méthode utilisée ici est celle de l’estimation par noyau (KDE). library(sf) library(spatstat) library(maptools) library(raster) # Import des données mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) # resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;, quiet = TRUE) sigma = 4000 res = 250 # Define an observation window w &lt;- as.owin(as(st_union(st_buffer(mtq, 100)), &quot;Spatial&quot;)) # sf to coords pts &lt;- st_coordinates(st_centroid(st_geometry(mtq))) # Coords to ppp p &lt;- ppp(pts[,1], pts[,2], window = w, marks = mtq$POP) # Compute KDE dens &lt;- density.ppp(p, weights = p$marks, sigma = sigma, eps = res) # Image to raster (+ proj &amp; km2) result &lt;- raster(dens, crs = st_crs(mtq)[[2]]) * 1000000 result &lt;- mask(result, mtq) # compute breaks bks &lt;- unique(getBreaks(values(result), nclass = 10, method = &quot;q6&quot;)) # Color ramp cols &lt;- hcl.colors(10, &quot;viridis&quot;)[2:8] # Plot the map plot(st_geometry(mtq), col = NA, border = NA, bg = &quot;lightblue1&quot;) plot(result, breaks = bks, col=cols, add = T,legend=F) plot(st_union(st_geometry(mtq)), add = T, lwd = 1.5, border = &quot;lightblue1&quot;) legendChoro( pos = &quot;topright&quot;, title.txt = &quot;Densité de\\npopulation\\n(hab./km2)&quot;, breaks = bks, nodata = FALSE, values.rnd = -1, col = cols ) layoutLayer(title = &quot;Densité de population&quot;, tabtitle = TRUE, author = &quot;INSEE, 2016&quot;, sources = &quot;&quot;, frame = FALSE, scale = 5) north(pos = &quot;topleft&quot;) 3.4 Cartes en 3D 3.4.1 linemap Le package linemap (Giraud 2017a) permet de réaliser des cartes composées de lignes. library(linemap) library(sf) data(&quot;popOcc&quot;) data(&quot;occitanie&quot;) opar &lt;- par(mar=c(0,0,0,0), bg = &quot;ivory2&quot;) bb &lt;- st_bbox(occitanie) plot(st_geometry(occitanie), col=&quot;ivory1&quot;, border = NA) linemap( x = popOcc, var = &quot;pop&quot;, k = 2.5, threshold = 50, col = &quot;ivory1&quot;, border = &quot;ivory4&quot;, lwd = 0.6, add = TRUE ) text(x = bb[1], y = bb[4],adj = c(0,1), labels = &quot;Répartition de la\\npopulation\\nen Occitanie&quot;, col = &quot;ivory4&quot;, font = 2, cex = 1.8) # add sources mapsources &lt;-&quot;Timothée Giraud\\nlinemap 0.1.0\\nDonnées carroyées à 1 kilomètre, INSEE 2010&quot; text(x = bb[3], y = bb[2],labels = mapsources, col = &quot;ivory4&quot;, font = 3, adj = c(1,0), cex = 0.6 ) 3.4.2 Relief Tanaka Nous utilisons le package tanaka (Giraud 2020) qui met à disposition une méthode (Tanaka 1950) utilisée pour améliorer la perception du relief. library(raster) library(cartography) library(sf) library(tanaka) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) # use WGS84 proj mtq_latlon &lt;- st_transform(mtq, 4326) # import raster ras &lt;- raster(&quot;data/srtm_24_10.tif&quot;) # crop on martinique area mtq_ras &lt;- crop(ras, st_bbox(mtq_latlon)[c(1,3,2,4)]) # aggregate the raster mtq_ras &lt;- aggregate(mtq_ras, fact=4, fun=mean) mtq_ras &lt;- projectRaster(mtq_ras, crs=st_crs(mtq)$proj4string) # break values bks &lt;- c(seq(0,1300,100),1302) # custom palette cols &lt;- c(&quot;#5D9D52&quot;, &quot;#8DBC80&quot;, &quot;#B8D9A9&quot;, &quot;#FDEBBE&quot;, &quot;#F7E0AC&quot;, &quot;#F2D69B&quot;, &quot;#EDCC8A&quot;, &quot;#E8C279&quot;, &quot;#E2B563&quot;, &quot;#DBA84C&quot;, &quot;#D49B36&quot;, &quot;#BA8428&quot;, &quot;#9A6A1E&quot;, &quot;#7B5114&quot;) # map plot(st_geometry(mtq), col = NA, border = NA, bg = &quot;lightblue1&quot;) tanaka( x = mtq_ras, breaks = bks, col = cols, legend.pos = &quot;NA&quot;, mask = mtq, add = TRUE ) legendChoro(pos = c(689000,1598000 ), breaks = bks, col = cols, nodata = F, title.txt = &quot;Elevation\\n(metres)&quot;, cex = 1) layoutLayer(title = &quot;Martinique Relief&quot;, north = T, sources = &#39;T. Giraud, 2019&#39;, author = &quot;SRTM, 2018&quot;, col = &quot;lightblue&quot;, tabtitle = T, coltitle = &quot;black&quot;) The tanaka package 3.4.3 Rayshader Le package rayshader (Morgan-Wall 2018) permet de réaliser de belles cartes en relief. L’export des images n’est pas évident, il s’agit ici d’une simple capture d’écran. library(sf) library(raster) library(rayshader) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) st_geometry(mtq) &lt;- st_buffer(st_geometry(mtq), 5000) mtq_latlon &lt;- st_transform(mtq, 4326) ras &lt;- raster(&quot;data/srtm_24_10.tif&quot;) mtq_ras &lt;- crop(ras, st_bbox(mtq_latlon)[c(1,3,2,4)]) mtq_ras &lt;- projectRaster(mtq_ras, crs=st_crs(mtq)$proj4string) elmat = matrix(extract(mtq_ras,extent(mtq_ras),buffer=1000), nrow=ncol(mtq_ras),ncol=nrow(mtq_ras)) elmat[is.na(elmat)] &lt;- 0 raymat = ray_shade(elmat,lambert = TRUE,anglebreaks = 85,sunangle = 125) ambmat = ambient_shade(elmat,anglebreaks = 85) elmat %&gt;% sphere_shade(texture = &quot;imhof1&quot;,sunangle = 125) %&gt;% add_water(detect_water(elmat), color=&quot;desert&quot;) %&gt;% add_shadow(raymat,0.5) %&gt;% add_shadow(ambmat,0.5) %&gt;% plot_3d(elmat,zscale=25,fov=10,theta=-15,phi=70, background=&quot;black&quot;, zoom=.5, windowsize =c(900, 900)) 3.5 Les cartogrammes L’anamorphose classique est une représentation des États (ou de mailles quelconques) par des rectangles ou des polygones quelconques en fonction d’une quantité qui leur est rattaché. (…) On s’efforce de garder l’arrangement général des mailles ou la silhouette du continent.\" Brunet, Ferras, and Théry (1993) 3 types d’anamorphoses ou cartogrammes sont ici présentés : Les cartogrammes de Dorling (Dorling 1996) Les cartogrammes non contigus (Olson 1976) Les cartogrammes contigus (Dougenik, Chrisman, and Niemeyer 1985) Un cours complet sur les anamorphoses : Les anamorphoses cartographiques (Lambert 2015). Faire des cartogrammes avec R Pour réaliser les cartogrammes nous utilisons le package cartogram (Jeworutzki 2018). 3.5.1 Les cartogrammes de Dorling Les territoires sont représentés par des figurés (cercles, des carrés ou des rectangles) ne se recouvrant pas dont les surfaces sont proportionnelles à une variable. Les positions des figurés sont définie selon les positions de départ. (McCormick 2017) On identifie assez mal l’espace. On peut nommer les cercles pour se repérer et/ou s’aider de la couleur pour faire apparaitre des clusters et mieux identifier les blocks géographiques. La perception des quantités est très bonne. Les tailles de cercles sont vraiment comparables. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) mtq_dorling &lt;- cartogram_dorling(x = mtq, weight = &quot;POP&quot;, k = 12) plot(st_geometry(mtq_dorling), col = &quot;#940000&quot;, border= &quot;white&quot;, bg = &quot;lightblue&quot;) labelLayer(x = mtq_dorling, txt = &quot;LIBGEO&quot;, overlap = FALSE, show.lines = FALSE, halo = TRUE, r = .15) layoutLayer(&quot;Population en Martinique - Cartogramme de Dorling&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) Le paramètre k permet de faire varier le facteur d’expansion des cercles. 3.5.2 Les cartogrammes non continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. La forme des polygones est ressemblante. (Cauvin, Escobar, and Serradj 2013) La topologie des régions est perdue. La conservation de la forme des polygones est optimale. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) mtq_ncont &lt;- cartogram_ncont(x = mtq, weight = &quot;POP&quot;, k = 1.5) plot(st_geometry(mtq), col = NA, border = &quot;white&quot;, lwd = 0.5, bg = &quot;lightblue&quot;) plot(st_geometry(mtq_ncont), col = &quot;#940000&quot;, border= &quot;white&quot;, add=TRUE) layoutLayer(&quot;Population en Martinique - Cartogramme de Olson&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) Le paramètre k permet de faire varier le facteur d’expansion des polygones. 3.5.3 Les cartogrammes continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. Pour conserver la contiguité, la forme des polygones est fortement transformée. (Paull and Hennig 2016) La forme des polygones est fortement distordue. C’est une “vraie carte de géographie” : la topologie et la contiguité sont conservées. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) mtq_cont &lt;- cartogram_cont(x = mtq, weight = &quot;POP&quot;, prepare = &quot;none&quot;) plot(st_geometry(mtq_cont), col = &quot;#940000&quot;, border= &quot;white&quot;, bg = &quot;lightblue&quot;) layoutLayer(&quot;Population en Martinique - Cartogramme de Dougenik&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) 3.5.4 Forces et faiblesses des cartogrammes Les cartogrammes sont des représentations cartographiques perçues comme innovante (bien que la methode date de 40 ans). Ces images très généralisées rendent bien compte des quantités et des gradiants. Ce sont de vraies images de communication qui provoquent, suscitent l’intérêt, véhiculent un message fort, interpellent. Mais les cartogrammes induisent une perte des repères visuels (difficile de retrouver son pays, ou sa région sur la carte), demandent un effort de lecture qui peut être important et ne permettent pas de gérer des données manquantes. 3.6 Cartographie interactive Le package mapview (Appelhans et al. 2018) utilise le package leaflet (Cheng, Karambelkar, and Xie 2018) basé sur la librairie javascript Leaflet (Agafonkin 2015) pour créer des cartes interactives. La création de carte est assez aisée, la documentation est un peu dense. Utilisation simple library(sf) library(leaflet.providers) library(mapview) mtq &lt;- st_read(system.file(&quot;gpkg/mtq.gpkg&quot;, package=&quot;cartography&quot;), quiet = TRUE) resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;, quiet = TRUE) mapview(resto) + mapview(mtq) Utilisation personnalisée mapview( resto, map.types = &quot;OpenStreetMap&quot;, col.regions = &quot;#940000&quot;, label = resto$name, alpha.regions=90, color = &quot;white&quot;, legend = TRUE, layer.name = &quot;Restaurants&quot;, homebutton = FALSE, lwd = 0.5, popup = NA ) + mapview( mtq, col.regions = &quot;lightblue&quot;, color = &quot;white&quot;, legend = TRUE, label = mtq$LIBGEO, alpha.regions= 0.5, map.types = &quot;OpenStreetMap&quot;, lwd = 0.5, layer.name = &quot;Communes&quot;, homebutton = FALSE, popup = leafpop::popupTable(mtq, zcol = 1:4, row.numbers = FALSE, feature.id = FALSE) ) References "],
["sessioninfo.html", "Chapitre 4 sessionInfo()", " Chapitre 4 sessionInfo() R version 4.0.0 (2020-04-24) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Debian GNU/Linux 10 (buster) Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.8.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.8.0 locale: [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C LC_TIME=fr_FR.UTF-8 [4] LC_COLLATE=fr_FR.UTF-8 LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C LC_ADDRESS=C [10] LC_TELEPHONE=C LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] mapview_2.7.8 leaflet.providers_1.9.0 cartogram_0.2.0 [4] tanaka_0.1.3 linemap_0.1.0 maptools_1.0-1 [7] spatstat_1.64-1 rpart_4.1-15 nlme_3.1-147 [10] spatstat.data_1.4-3 mapinsetr_0.3.0 png_0.1-7 [13] raster_3.1-5 sp_1.4-2 cartography_2.4.1 [16] sf_0.9-3 knitr_1.28 loaded via a namespace (and not attached): [1] Rcpp_1.0.4.6 svglite_1.2.3 lattice_0.20-41 [4] deldir_0.1-25 class_7.3-17 digest_0.6.25 [7] R6_2.4.1 leafpop_0.0.5 stats4_4.0.0 [10] evaluate_0.14 e1071_1.7-3 tensor_1.5 [13] gdtools_0.2.2 rlang_0.4.6 uuid_0.1-4 [16] rstudioapi_0.11 Matrix_1.2-18 goftest_1.2-2 [19] rmarkdown_2.2 splines_4.0.0 webshot_0.5.2 [22] rgdal_1.5-8 stringr_1.4.0 foreign_0.8-79 [25] htmlwidgets_1.5.1 polyclip_1.10-0 munsell_0.5.0 [28] compiler_4.0.0 xfun_0.14 systemfonts_0.2.2 [31] base64enc_0.1-3 mgcv_1.8-31 rgeos_0.5-3 [34] htmltools_0.4.0 bookdown_0.19 codetools_0.2-16 [37] viridisLite_0.3.0 grid_4.0.0 jsonlite_1.6.1 [40] lwgeom_0.2-4 satellite_1.0.2 lifecycle_0.2.0 [43] DBI_1.1.0 magrittr_1.5 units_0.6-6 [46] scales_1.1.1 KernSmooth_2.23-17 stringi_1.4.6 [49] leaflet_2.0.3 brew_1.0-6 packcircles_0.3.3 [52] spatstat.utils_1.17-0 RColorBrewer_1.1-2 tools_4.0.0 [55] leafem_0.1.1 crosstalk_1.1.0.1 abind_1.4-5 [58] yaml_2.2.1 colorspace_1.4-1 classInt_0.4-3 [61] isoband_0.2.1 "],
["references.html", "References", " References "]
]
