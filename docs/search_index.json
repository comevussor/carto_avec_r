[
["chapitre3.html", "Chapitre 3 Cartographie thématique avancée 3.1 Les cartes de discontinuités 3.2 Les grilles régulières 3.3 Le lissage spatial 3.4 Cartes en 3D 3.5 Les cartogrammes 3.6 Cartographie interactive", " Chapitre 3 Cartographie thématique avancée 3.1 Les cartes de discontinuités Ce type de représentation permet de souligner cartographiquement les discontinuités territoriales d’un phénomène. L’accent est porté sur ce qui distingue des territoires. Pour chaque frontière nous calculons le rapports ou la différence des valeurs des polygones de part et d’autre. Puis nous représentons la frontière par un figuré d’autant plus épais que la différence est forte. Il est souvent bénéfique de coupler ce type de représentation à une représentation choroplèthe (pour comprendre le sens des discontinuités). Ces cartes ne sont pas évidentes à paramétrer. Le choix des critères (seuil, type de différences…) influence fortement la représentation. En fonction du maillage utilisé la lisibilité de la carte peut être faible. Ces représentations sont très puissantes pour montrer les inégalités. La fonctions getBorder() du package cartography permet de construire une couche des frontières terrestres. La fonction discLayer() permet d’afficher les discontinuités. library(sf) library(cartography) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # Get borders mtq_bord &lt;- getBorders(x = mtq) # Plot polygons plot(st_geometry(mtq), border = NA, col = &quot;grey60&quot;) # Plot borders plot( st_geometry(mtq_bord), col = sample(x = rainbow(nrow(mtq_bord))), lwd = 3, add = TRUE ) layoutLayer(&quot;Frontières inter-communales&quot;,tabtitle=TRUE, north = TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) mtq$emp_share &lt;- 100 * mtq$C13_CS5/mtq$C13_POP # Plot this share choroLayer( x = mtq, var = &quot;emp_share&quot;, border = NA, method = &#39;quantile&#39;, nclass = 6, legend.values.rnd = 1, legend.pos = &quot;topright&quot;, legend.title.txt = &quot;Part des employés\\ndans la population agée\\nde 15 ans et plus&quot; ) # Plot discontinuities discLayer( x = mtq_bord, df = mtq, var = &quot;emp_share&quot;, col=&quot;darkred&quot;, nclass=3, method=&quot;quantile&quot;, threshold = 0.5, sizemin = 0.5, sizemax = 8, type = &quot;abs&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Discontinuités\\n(différences absolues)&quot;, legend.pos = &quot;bottomleft&quot;, add=TRUE ) layoutLayer(&quot;Discontinuités - Part des employés&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) 3.2 Les grilles régulières La méthode du carroyage consiste à découper l’espace géographique en un maillage formé de carrés réguliers dans une projection donnée. La donnée est répartie sur ce quadrillage régulier au prorata de la surface représentée. Le quadrillage permet ainsi de s’affranchir des mailles administratives. Ces représentation induisent une perte de précision. Les maillages produit n’ont pas de signification. La version simple (les valeurs sont redistribuées au prorata de la surface), implique une equirépartition du phénomène dans chaque unités. La comparaison de maillages différents, à plusieurs dates ou de différentes sources est rendue possible. La fonction getGridLayer() du package cartography permet de construire ces grilles régulières. library(sf) library(cartography) library(sp) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # Plot dentsity of population mtq$dens &lt;- mtq$P13_POP / (st_area(mtq) / (1000 * 1000)) bks &lt;- getBreaks(v = mtq$dens, method = &quot;q6&quot;) cols &lt;- carto.pal(pal1 = &quot;taupe.pal&quot;, n1 = 6) choroLayer( x = mtq, var = &quot;dens&quot;, breaks = bks, border = &quot;burlywood3&quot;, col = cols, legend.pos = &quot;topright&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Densité de population\\n(hab/km2)&quot; ) layoutLayer(&quot;Population en Martinique&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) # Création de la grille mygrid &lt;- getGridLayer( x = mtq, cellsize = 10000 * 10000, type = &quot;hexagonal&quot;, var = &quot;P13_POP&quot; ) ## conversion from square meter to square kilometers mygrid$densitykm &lt;- mygrid$P13_POP / (mygrid$gridarea / (1000 * 1000)) choroLayer( x = mygrid, var = &quot;densitykm&quot;, breaks = bks, border = &quot;burlywood3&quot;, col = cols, legend.pos = &quot;topright&quot;, legend.values.rnd = 1, legend.title.txt = &quot;Densité de population\\n(hab/km2)&quot; ) plot(st_geometry(mtq), lwd = 0.2, add=TRUE, border = &quot;#ffffff75&quot;) layoutLayer( title = &quot;Population en Martinique&quot;, tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5 ) north(pos = &quot;topleft&quot;) 3.3 Le lissage spatial L’idée principale du lissage est de filtrer l’information pour révéler des structures spatiales sous-jacentes. C’est un ensemble de méthodes qui consistent à affecter aux points que l’on observe une valeur prenant en compte les valeurs de leur voisinage. Il existe plusieurs méthodes de lissage (kde, potentiels…) plus ou moins paramétrables. Cette méthode permet de passer d’une représentations de données ponctuelles vers la représentation d’une surface continue. Il est difficile de paramétrer correctement les fonctions de lissages. Elles doivent s’appuyer sur des hypothèses de comportement dans l’espace. La compréhension par un public large n’est pas évidente, il faut alors simplifier les légendes, la présentation de la méthode. Permet de faire ressortir des phénomènes spatiaux sous-jacents invisibles directement. Les cartes produites attirent l’oeil par leur originalité. Cette méthode permet de passer d’une représentation ponctuelle ou discontinue (dans un maillage) à une représentation continue s’affranchissant des maillages existants. La méthode utilisée ici est celle de l’estimation par noyau (KDE). library(sf) library(spatstat) library(maptools) library(raster) # Import des données mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;, quiet = TRUE) sigma = 1000 res = 200 # Define an observation window w &lt;- as.owin(as(mtq, &quot;Spatial&quot;)) # sf to coords pts &lt;- st_coordinates(resto) # Coords to ppp p &lt;- ppp(pts[,1], pts[,2], window=w) # Compute KDE dens &lt;- density.ppp(p, sigma = sigma, eps = res) # Image to raster (+ proj &amp; km2) result &lt;- raster(dens, crs = st_crs(resto)[[2]]) * 1000000 # compute breaks bks &lt;- unique(getBreaks(values(result), nclass = 8, method = &quot;arith&quot;)) # Color ramp cols &lt;- mapview::mapviewGetOption(&quot;raster.palette&quot;)(10)[2:9] # Plot the map plot(st_geometry(mtq), col = &quot;lightblue4&quot;, border = &quot;lightblue3&quot;, bg = &quot;lightblue1&quot;) plot(result, breaks = bks, col=cols, add = T,legend=F) plot(resto$geom, add=T, pch = 20, cex = 0.01, col = &quot;white&quot;) legendChoro( pos = &quot;topright&quot;, title.txt = &quot;Densité de\\nrestaurants\\n(N./km2)&quot;, breaks = bks, nodata = FALSE, values.rnd = 1, col = cols ) layoutLayer(title = &quot;Répartition des restaurants&quot;,tabtitle=TRUE, author= &quot;INSEE, 2016 - OSM, 2018&quot;, sources=&quot;&quot;, frame=FALSE, scale = 5) north(pos = &quot;topleft&quot;) 3.4 Cartes en 3D 3.4.1 linemap Le package linemap (Giraud 2017) permet de réaliser des cartes composées de lignes. library(linemap) library(sf) data(&quot;popOcc&quot;) data(&quot;occitanie&quot;) opar &lt;- par(mar=c(0,0,0,0), bg = &quot;ivory2&quot;) bb &lt;- st_bbox(occitanie) plot(st_geometry(occitanie), col=&quot;ivory1&quot;, border = NA) linemap( x = popOcc, var = &quot;pop&quot;, k = 2.5, threshold = 50, col = &quot;ivory1&quot;, border = &quot;ivory4&quot;, lwd = 0.6, add = TRUE ) text(x = bb[1], y = bb[4],adj = c(0,1), labels = &quot;Répartition de la\\npopulation\\nen Occitanie&quot;, col = &quot;ivory4&quot;, font = 2, cex = 1.8) # add sources mapsources &lt;-&quot;Timothée Giraud\\nR 3.4.1, cartography 2.0.0, linemap 0.1.0\\nDonnées carroyées à 1 kilomètre, INSEE 2010&quot; text(x = bb[3], y = bb[2],labels = mapsources, col = &quot;ivory4&quot;, font = 3, adj = c(1,0), cex = 0.6 ) 3.4.2 Relief Tanaka Cette méthode (Tanaka 1950) est utilisée pour améliorer la perception du relief. library(raster) library(cartography) library(sf) library(SpatialPosition) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE)# use WGS84 proj mtq_latlon &lt;- st_transform(mtq, 4326) # import raster ras &lt;- raster(&quot;data/srtm_24_10.tif&quot;) # crop on martinique area mtq_ras &lt;- crop(ras, st_bbox(mtq_latlon)[c(1,3,2,4)]) # aggregate the raster mtq_ras &lt;- aggregate(mtq_ras, fact=4,fun=mean) mtq_ras &lt;- projectRaster(mtq_ras, crs=st_crs(mtq)$proj4string) # break values bv &lt;- c(seq(0,1300,100),1339) # contour extraction mtq_cont &lt;- rasterToContourPoly(r = mtq_ras, breaks = bv, mask = as(mtq, &quot;Spatial&quot;)) # custom palette pal &lt;- c(&quot;#5D9D52&quot;, &quot;#8DBC80&quot;, &quot;#B8D9A9&quot;, &quot;#FDEBBE&quot;, &quot;#F7E0AC&quot;, &quot;#F2D69B&quot;, &quot;#EDCC8A&quot;, &quot;#E8C279&quot;, &quot;#E2B563&quot;, &quot;#DBA84C&quot;, &quot;#D49B36&quot;, &quot;#BA8428&quot;, &quot;#9A6A1E&quot;, &quot;#7B5114&quot;) # sp to sf k &lt;- st_as_sf(mtq_cont) # order the sf k &lt;- k[order(k$center),] plot(st_geometry(mtq), col = NA, border = NA, bg = &quot;lightblue&quot;) for(i in 1:nrow(k)){ p &lt;- st_geometry(k[i,]) plot(p + c(-50, 50), add=T, border = &quot;#ffffff90&quot;,col = &quot;#ffffff90&quot;) plot(p + c(100, -100), col = &quot;#00000090&quot;, add=T, border = &quot;#00000090&quot;) plot(p, col = pal[i], border = &quot;NA&quot;, add=T) } legendChoro(pos = c(689000,1598000 ), breaks = bv, col = pal, nodata = F, title.txt = &quot;Elevation\\n(metres)&quot;, cex = 1) layoutLayer(title = &quot;Martinique Relief&quot;, north = T, sources = &#39;T. Giraud, 2019&#39;, author = &quot;SRTM, 2018&quot;, col = &quot;lightblue&quot;, tabtitle = T, coltitle = &quot;black&quot;) 3.4.3 Rayshader Le package rayshader (Morgan-Wall 2018) permet de réaliser de belles cartes en relief. L’export des images n’est pas évident, il s’agit ici d’une simple capture d’écran. library(sf) library(raster) library(rayshader) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) st_geometry(mtq) &lt;- st_buffer(st_geometry(mtq), 5000) mtq_latlon &lt;- st_transform(mtq, 4326) ras &lt;- raster(&quot;data/srtm_24_10.tif&quot;) mtq_ras &lt;- crop(ras, st_bbox(mtq_latlon)[c(1,3,2,4)]) mtq_ras &lt;- projectRaster(mtq_ras, crs=st_crs(mtq)$proj4string) elmat = matrix(extract(mtq_ras,extent(mtq_ras),buffer=1000), nrow=ncol(mtq_ras),ncol=nrow(mtq_ras)) elmat[is.na(elmat)] &lt;- 0 raymat = ray_shade(elmat,lambert = TRUE,anglebreaks = 85,sunangle = 125) ambmat = ambient_shade(elmat,anglebreaks = 85) elmat %&gt;% sphere_shade(texture = &quot;imhof1&quot;,sunangle = 125) %&gt;% add_water(detect_water(elmat), color=&quot;desert&quot;) %&gt;% add_shadow(raymat,0.5) %&gt;% add_shadow(ambmat,0.5) %&gt;% plot_3d(elmat,zscale=25,fov=10,theta=-15,phi=70, background=&quot;black&quot;, zoom=.5, windowsize =c(900, 900)) 3.5 Les cartogrammes L’anamorphose classique est une représentation des États (ou de mailles quelconques) par des rectangles ou des polygones quelconques en fonction d’une quantité qui leur est rattaché. (…) On s’efforce de garder l’arrangement général des mailles ou la silhouette du continent.&quot; Brunet, Ferras, and Théry (1993) 3 types d’anamorphoses ou cartogrammes sont ici présentés : Les cartogrammes de Dorling (Dorling 1996) Les cartogrammes non contigus (Olson 1976) Les cartogrammes contigus (Dougenik, Chrisman, and Niemeyer 1985) Vous trouverez un cours complet sur les anamorphoses ici : Les anamorphoses cartographiques (Lambert 2015). Pour réaliser les cartogrammes nous utilisons le package cartogram (Jeworutzki 2018). 3.5.1 Les cartogrammes de Dorling Les territoires sont représentés par des figurés (cercles, des carrés ou des rectangles) ne se recouvrant pas dont les surfaces sont proportionnelles à une variable. Les positions des figurés sont définie selon les positions de départ. (McCormick 2017) On identifie assez mal l’espace. On peut nommer les cercles pour se repérer et/ou s’aider de la couleur pour faire apparaitre des clusters et mieux identifier les blocks géographiques. La perception des quantités est très bonne. Les tailles de cercles sont vraiment comparables. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) mtq_dorling &lt;- cartogram_dorling(x = mtq, weight = &quot;P13_POP&quot;, k = 12) plot(st_geometry(mtq_dorling), col = &quot;#940000&quot;, border= &quot;white&quot;, bg = &quot;lightblue&quot;) labelLayer(x = mtq_dorling, txt = &quot;LIBGEO&quot;, overlap = FALSE, show.lines = FALSE, halo = TRUE, r = .15) layoutLayer(&quot;Population en Martinique - Cartogramme de Dorling&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) Le paramètre k permet de faire varier le facteur d’expansion des cercles. 3.5.2 Les cartogrammes non continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. La forme des polygones est ressemblante. (Cauvin, Escobar, and Serradj 2013) La topologie des régions est perdue. La conservation de la forme des polygones est optimale. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) mtq_ncont &lt;- cartogram_ncont(x = mtq, weight = &quot;P13_POP&quot;, k = 1.5) plot(st_geometry(mtq), col = NA, border = &quot;white&quot;, lwd = 0.5, bg = &quot;lightblue&quot;) plot(st_geometry(mtq_ncont), col = &quot;#940000&quot;, border= &quot;white&quot;, add=TRUE) layoutLayer(&quot;Population en Martinique - Cartogramme de Olson&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) Le paramètre k permet de faire varier le facteur d’expansion des polygones. 3.5.3 Les cartogrammes continus La taille des polygones est proportionnelle à une variable. L’agencement des polygones les uns par rapport aux autres est conservée. Pour conserver la contiguité, la forme des polygones est fortement transformée. (Paull and Hennig 2016) La forme des polygones est fortement distordue. C’est une “vraie carte de géographie” : la topologie et la contiguité sont conservées. library(cartography) library(cartogram) library(sf) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet = TRUE) # transformation POLYGON =&gt; MULTIPOLYGON mtq &lt;- st_cast(mtq, &quot;MULTIPOLYGON&quot;) mtq_cont &lt;- cartogram_cont(x = mtq, weight = &quot;P13_POP&quot;, prepare = &quot;none&quot;) plot(st_geometry(mtq_cont), col = &quot;#940000&quot;, border= &quot;white&quot;, bg = &quot;lightblue&quot;) layoutLayer(&quot;Population en Martinique - Cartogramme de Dougenik&quot;,tabtitle=TRUE, author= &quot;INSEE 2016&quot;, sources=&quot;&quot;, frame=FALSE, scale = NULL) 3.5.4 Forces et faiblesses des cartogrammes Les cartogrammes sont des représentations cartographiques perçues comme innovante (bien que la methode date de 40 ans). Ces images très généralisées rendent bien compte des quantités et des gradiants. Ce sont de vraies images de communication qui provoquent, suscitent l’intérêt, véhiculent un message fort, interpellent. Mais les cartogrammes induisent une perte des repères visuels (difficile de retrouver son pays, ou sa région sur la carte), demandent un effort de lecture qui peut être important et ne permettent pas de gérer des données manquantes. 3.6 Cartographie interactive Le package mapview (Appelhans et al. 2018) utilise le package leaflet (Cheng, Karambelkar, and Xie 2018) basé sur la librairie javascript Leaflet (Agafonkin 2015) pour créer des cartes interactives. La création de carte est assez aisée, la documentation est un peu dense. Utilisation simple library(sf) library(mapview) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet=TRUE) resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;, quiet = TRUE) mapview(resto) + mapview(mtq) Utilisation personnalisée library(sf) library(mapview) mtq &lt;- st_read(&quot;data/martinique.shp&quot;, quiet=TRUE) resto &lt;- st_read(dsn = &quot;data/resto.gpkg&quot;, quiet = TRUE) mapview( resto, map.types = &quot;OpenStreetMap&quot;, col.regions = &quot;#940000&quot;, label = resto$name, alpha.regions=90, color = &quot;white&quot;, legend = TRUE, layer.name = &quot;Restaurants&quot;, homebutton = FALSE, lwd = 0.5, popup = NA ) + mapview( mtq, col.regions = &quot;lightblue&quot;, color = &quot;white&quot;, legend = TRUE, label = mtq$LIBGEO, alpha.regions= 0.5, map.types = &quot;OpenStreetMap&quot;, lwd = 0.5, layer.name = &quot;Communes&quot;, homebutton = FALSE, popup = popupTable(mtq, zcol = 1:4, row.numbers = FALSE, feature.id = FALSE) ) References "]
]
